#+TITLE: Shared Buffer
#+SUBTITLE: The Specification, Verification and Implementation of a Real-Time Collaborative Editing System
#+AUTHOR: Lars Tveito
#+EMAIL: larstvei@ifi.uio.no
#+DATE: August 2016
#+OPTIONS: num:3 H:5 todo:nil title:nil toc:nil ':t
#+LaTeX_CLASS_OPTIONS: [USenglish, hidelinks]
#+LaTeX_CLASS: ifimaster
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{shapes, arrows, arrows.meta, positioning}
#+LATEX_HEADER: \usepackage[backend=biber,bibencoding=utf8]{biblatex}
#+LATEX_HEADER: \usepackage{amsthm, parskip, multicol}
#+LATEX_HEADER: \bibliography{ref}
#+LaTeX_HEADER: \urlstyle{sf}

#+LaTeX_HEADER: \newcommand{\ins}[2]{ins(#1,\ \texttt{#2})}
#+LaTeX_HEADER: \newcommand{\del}[2]{del(#1,\ \texttt{#2})}
#+LaTeX_HEADER: \newenvironment{ritemize}{\begin{itemize}\raggedright}{\end{itemize}}

#+LaTeX: \pgfdeclarelayer{bg}    % declare background layer
#+LaTeX: \pgfsetlayers{bg,main}  % set the order of the layers (main is the standard layer)

#+LaTeX: \ififorside{}
#+LaTeX: \frontmatter{}
#+LaTeX: \maketitle{}

#+BEGIN_abstract
Placeholder for abstract.
#+END_abstract

#+LaTeX: \tableofcontents{}
#+LaTeX: \listoffigures{}
#+LaTeX: \listoftables{}
* Acknowledgements
  :PROPERTIES:
  :UNNUMBERED: t
  :END:

Thanks to Rudi and Martin, Tore, Sigurd, Stian, Carl Martin, Kai, Jarle, Joshi,
Fui, Sigmund, Jonny, Simen, my family, and so many more.

* Preface
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
  In 2013 [[http://lispnyc.org][LispNYC]], [[http://www.meetup.com/Clojure-NYC/][ClojureNYC]] and [[http://alu.org][Association of Lisp Users]] hosted a
  programming competition called [[http://lispinsummerprojects.org/][LISP In Summer Projects]], awarding cash prizes
  for Lisp-related projects. They gathered some great finalist judges: Matthias
  Felleisen, Richard Gabriel, Rich Hickey, Peter Norvig, Christian Queinnec and
  Taiichi Yuasa.

  Around the time of the announcement of the competition, I attended a course
  on functional programming, in which we were to collaborate on programming
  assignments in small teams (of two or three participants). Mostly, we
  programmed together whilst in the same room (physically), and at any given
  moment, the one with the most promising idea held the keyboard. Sometimes we
  all wanted to explore some idea, and we would have to type it out on separate
  computers, and synchronize our changes thereafter.

  At times we (or at least I) felt it broke our flow. I started investigating
  how to allow separate Emacs sessions communicate using network processes, and
  realized it was completely plausible to enable real-time collaboration in
  Emacs.

  Seeing the aforementioned competition announcement, I immediately decided
  that implementing real-time collaboration in Emacs would make the perfect
  project.

  My approach was quite naïve, and it was developed using a trial and error
  approach. By the end of the summer I had a rough prototype that worked for
  what I deemed "the most common use-cases". It had a very serious problem: All
  changes were applied under the assumption of consistency between clients, but
  this assumption proved false in non-trivial use-cases. There was no recovery
  mechanism in place, and if consistency was breached, then it would be up to
  the user to detect this, and reconnect.

  Still, the judges of the competition deemed the program worthy of second
  prize, awarding me $500 for my efforts.

  It was by far the most ambitious project I've embarked on, and also the most
  rewarding. I was greatly honored for receiving the prize, and feel my
  gratitude should be expressed in elegant Lisp code, that compose a working
  implementation of the program I wished I had written back in 2013.

#+LaTeX: \mainmatter{}
* Introduction

  A real-time collaborative editor enables multiple users, at (potentially)
  different locations, to simultaneously work on the same document. The idea
  has been around for a long time, and was demoed by Douglas Engelbart in the
  Mother of All Demos cite:engelbart1968mother already in 1968. In this thesis
  we aim to formally verify and develop a system for real-time collaboration.

  First, let us make it clear what we will characterize as a real-time
  collaborative editor. An /editor/ is a program that allows a user to
  manipulate a document. The editor is considered /collaborative/ if it has
  features that makes it easier for multiple users to form a document together.
  Furthermore, it is considered /real-time/ if multiple users can edit the
  document simultaneously cite:ellis1989concurrency, and that changes are
  propagated to the other users within a reasonably short amount of time.

  The first actual implementation of such an editor that was documented in the
  literature, came with GROVE (GROUP Outline Viewing Editor)
  cite:ellis1989concurrency, which introduced the concept of /Operational
  Transformation/ (OT) which we will cover thoroughly in Chapter [[Formal
  Semantics of Editing Operations]]. Previous systems
  cite:Greif:1986:ADA:512644.512659,Fish:1988:QCT:45410.45414,Lewis:1988:SBC:45410.45431
  that provided collaborative capabilities were not considered /real-time/
  systems by cite:ellis1989concurrency, because users could not edit the same
  section of the document simultaneously.

  The reader might be familiar with [[https://www.google.com/docs/about/][Google Docs]], which is an example of a
  modern real-time collaborative document WYSIWYG (What You See Is What You
  Get) editor with over 240 million monthly active users cite:NextWeb2014. It
  is largely based on OT cite:WaveOT, but has also initiated research in a
  technique called Differential Synchronization cite:Fraser:09. Through its
  integration with [[https://www.google.com/drive/][Google Drive]], it offers a collaborative platform, where
  users can both store and manipulate their documents, as long as they have a
  internet connection, along with a (fairly modern) browser.

  We will present a tool for real-time collaborative editing called Shared
  Buffer, which is designed with developers in mind. What most developers have
  in common is that they spend a lot of time manipulating /plain text/, yet
  they use a lot of different tools to do so cite:stackoverflowdevelopersurvey,
  therefore we aim to enable real-time collaboration in /existing/ text
  editors, as opposed to developing an editor with real-time collaborative
  features. We therefore want to develop a protocol which ideally should be
  portable to any text editor, or any program that embeds a text editor.

  A client-server model is chosen, as opposed to a fully decentralized
  solution. We will consequently move complexity to the server, if this can
  simplify the client-side algorithm; this is chosen in order to ensure
  portability. Furthermore, proving correctness for a fully decentralized
  solution has proven to be very difficult
  cite:formalOT,DBLP:journals/corr/abs-1302-3292,Imine2003.

  Our prototype client is for the text editor Emacs. The name Shared Buffer
  reflects a choice in design; in Emacs, text is stored in a /buffer/; when a
  file is opened, its contents is put inside a buffer, which the user can
  manipulate. You may also have buffers that are not associated with any file.
  In Shared Buffer, there is no notion of a file, meaning there is no centrally
  stored copy of the document.

  The server will be written in [[https://clojure.org/][Clojure]], a modern functional programming
  language with strong concurrency semantics cite:Emerick2012. Being hosted on
  the JVM, Clojure offers full Java interoperability, meaning that we can
  leverage the vast collection of Java libraries.

** A Naïve Algorithm

   Let us now consider two cases that illustrates how a naïve implementation
   (like the one briefly described in the [[Preface]]) might work, and where it
   fails to produce a desirable result.

   Say we have two users, our European friend $u_0$ and $u_1$, the American,
   who are both communicating with a server $S$. They each have a copy of a
   shared buffer. Both may either insert a character, or delete one from the
   buffer, and they may do so at any time. When a user performs an operation
   (meaning insertion or deletion) on its local buffer, then this should be
   communicated to $S$. When $S$ receives an operation, it should communicate
   this to the other user.

   We represent scenarios that can occur in the system graphically by using a
   variation of message sequence charts. The diagrams are read from top to
   bottom with regards to time, where directed edges represents the transfer of
   a message.

   #+BEGIN_EXPORT latex
   \begin{figure}[h]
     \centering
     \begin{tikzpicture}[>=stealth, shorten >= 5pt, node distance=1em, scale=1]
       \tikzstyle{vertex} = [circle, scale=0.5]
       \tikzstyle{O_0} = [vertex, fill=black!30!green]
       \tikzstyle{O_1} = [vertex, fill=black!30!blue]

       \tikzstyle{to} = [-{Stealth[scale=1.2]}]
       \tikzstyle{toO_0} = [to, color=black!30!green]
       \tikzstyle{toO_1} = [to, color=black!30!blue]

       \tikzstyle{op} = [midway, above=-3pt, sloped, text=black, font=\small]

       %% Server receives operations in this order
       \node (s) at (3, 4) {$S$};
       \coordinate (se) at (3, 0) {};
       \node[O_0, below = 2em of s] (s1) {};
       \node[O_1, below = 3.2em of s1] (s2) {};

       %% User 0 generates/receives in this order
       \node (u0) at (0, 4) {$u_0$};
       \node (u0e) at (0, 0) {};
       \node[O_0, below = of u0, label=left:{\texttt{a}}] (u00) {};
       \node[O_1, above = 2em of u0e, label=left:{\texttt{ba}}] (u01a) {};

       %% User 1 generates/receives in this order
       \node (u1) at (6, 4) {$u_1$};
       \node (u1e) at (6, 0) {};
       \node[O_0, below = 3em of u1, label=right:{\texttt{a}}] (u10a) {};
       \node[O_1, below = 1em of u10a, label=right:{\texttt{ba}}] (u11) {};

       \begin{pgfonlayer}{bg} % select the background layer
         \draw[to, color=black!30] (s) -- (s1)  -- (s2) -- (se);
         \draw[to, color=black!30] (u0) -- (u00) -- (u01a) -- (u0e);
         \draw[to, color=black!30] (u1) -- (u11) -- (u10a) -- (u1e);

         % Life of O_0
         \draw[toO_0] (u00) -- (s1) node [op] {$\overbrace{\ins{0}{a}}^{O_0}$};
         \draw[toO_0] (s1) -- (u10a) node [op, near end] {$O_0$};

         % Life of O_1
         \draw[toO_1] (u11) -- (s2) node [op] {$\overbrace{\ins{0}{b}}^{O_1}$};
         \draw[toO_1] (s2) -- (u01a) node [op, near end] {$O_1$};
       \end{pgfonlayer}
     \end{tikzpicture}
     \caption{A conflict-free scenario with two clients.}
     \label{fig:noconflict0}
   \end{figure}
   #+END_EXPORT

   Figure [[ref:fig:noconflict0]] describes a very simple scenario. Imagine that
   $u_0$ has an empty buffer which she precedes to insert an ="a"= into.
   Meanwhile, $u_1$ inserts a ="b"= in front of the ="a"= that just popped up in
   her buffer. The ="b"= eventually reaches $u_0$, and the end result of the
   interaction is that they both will be looking at a buffer containing ="ba"=.
   In this scenario the buffers ended up identical, so we say that we reached a
   /consistent state/.

   Simple scenarios like the one we saw, where only one message is "in flight"
   at any one time, would be gracefully handled by even the naïve approach. We
   can see that ="a"= was inserted prior to the ="b"= at both $u_0$ and $u_1$,
   hence they cannot have been applied concurrently. We will now demonstrate
   that the approach does not work when we introduce concurrent edits.

   Let us return to the example from Figure [[ref:fig:noconflict0]], with a slight
   modification, visualized in Figure [[ref:fig:conflict0]]. The scenario is
   unchanged at $u_0$, where she first inserts an ="a"=, and later receives the
   ="b"= which leaves her with a buffer containing ="ba"=. Now say that $u_1$
   inserts her ="b"= /before/ having received the ="a"=. When she has already
   typed a ="b"=, she receives a message saying that she should place an ="a"=
   at the first point in her buffer. The resulting buffer is ="ab"=. Now they
   are looking at different buffers, so we say we have reached an /inconsistent
   state/.

   #+BEGIN_EXPORT latex
   \begin{figure}[h]
     \centering
     \begin{tikzpicture}[>=stealth, shorten >= 5pt, node distance=1em, scale=1]
       \tikzstyle{vertex} = [circle, scale=0.5]
       \tikzstyle{O_0} = [vertex, fill=black!30!green]
       \tikzstyle{O_1} = [vertex, fill=black!30!blue]

       \tikzstyle{to} = [-{Stealth[scale=1.2]}]
       \tikzstyle{toO_0} = [to, color=black!30!green]
       \tikzstyle{toO_1} = [to, color=black!30!blue]

       \tikzstyle{op} = [midway, above=-3pt, sloped, text=black, font=\small]

       %% Server receives operations in this order
       \node (s) at (3, 4) {$S$};
       \coordinate (se) at (3, 0) {};
       \node[O_0, below = 3em of s] (s1) {};
       \node[O_1, below = 1em of s1] (s2) {};

       %% User 0 generates/receives in this order
       \node (u0) at (0, 4) {$u_0$};
       \node (u0e) at (0, 0) {};
       \node[O_0, below = of u0, label=left:{\texttt{a}}] (u00) {};
       \node[O_1, above = 2em of u0e, label=left:{\texttt{ba}}] (u01a) {};

       %% User 1 generates/receives in this order
       \node (u1) at (6, 4) {$u_1$};
       \node (u1e) at (6, 0) {};
       \node[O_1, below = 1.5em of u1, label=right:{\texttt{b}}] (u11) {} ;
       \node[O_0, below = 3em of u11, label=right:{\texttt{ab}}] (u10a) {};

       \begin{pgfonlayer}{bg} % select the background layer
         \draw[to, color=black!30] (s) -- (s1)  -- (s2) -- (se);
         \draw[to, color=black!30] (u0) -- (u00) -- (u01a) -- (u0e);
         \draw[to, color=black!30] (u1) -- (u11) -- (u10a) -- (u1e);

         % Life of O_0
         \draw[toO_0] (u00) -- (s1) node [op] {$\overbrace{\ins{0}{a}}^{O_0}$};
         \draw[toO_0] (s1) -- (u10a) node [op, near end] {$O_0$};

         % Life of O_1
         \draw[toO_1] (u11) -- (s2) node [op] {$\overbrace{\ins{0}{b}}^{O_1}$};
         \draw[toO_1] (s2) -- (u01a) node [op, near end] {$O_1$};
       \end{pgfonlayer}
     \end{tikzpicture}
     \caption{A minimal conflict with two clients.}
     \label{fig:conflict0}
   \end{figure}
   #+END_EXPORT

   In this thesis we introduce and discuss a new protocol which guarantees
   /eventual consistency/ cite:Vogels:2009:EC:1435417.1435432 between
   participating clients. Intuitively, this means that if all users stop typing
   at some point, then given enough time for traveling messages to reach their
   destination, they will all be looking at the same buffer. In later chapters
   we will come to realize that is not at all trivial, considering the highly
   concurrent and distributed nature of the problem. In order to handle this
   level of complexity we will rely heavily on the use of formal methods.

** Method

   In this thesis we use a formal verification technique called /model
   checking/ cite:Clarke:2000:MC:332656. This technique requires us to obtain a
   mathematical model of the system we wish to validate. A model is represented
   as a set of states, and transitions between these states. We can think of
   model checking as a graph search, where the states acts as nodes, and edges
   represent the possibility of going from one state to another. If the graph
   is finite, we can prove that the model has a certain property by checking
   whether the property holds true in every state. Furthermore, we want to use
   Linear Temporal Logic (LTL) to express properties over paths, which are
   sequences of states.

   The model is generally an abstraction of a given system, where one carefully
   chooses what parts of the system is necessary to represent, in order to
   prove the properties that are of interest.

   Moreover, we will use the model as a way of driving the development process,
   or rather, solving the problem. When model checking a property, a counter
   example is given if the property does not hold. By studying the example, we
   can change the model in hope of resolving the issue, and see the effects of
   the change. This resembles Test Driven Development (TDD), but instead of
   testing our actual system we perform tests on a model, and rather than
   testing a few selected scenarios, we check all possible scenarios.

   [[http://maude.cs.illinois.edu/][The Maude System]] is our chosen modeling language and verification tool. It
   provides an expressive language, that is well suited for modeling concurrent
   and distributed systems [[cite:DBLP:conf/maude/2007]]. In addition, it provides
   The LTL Model Checker cite:Eker2004162, which allows us to specify and
   verify LTL properties.

** Contributions

   The main result of this thesis is a protocol that enables real-time
   collaborative editing. Both a client- and server-side algorithm have been
   developed and modeled. The model has been formally verified to guarantee
   eventual consistency for a limited number of clients and operations.

   To this end we:
   - provide a mathematical description of our system based on OT,
   - demonstrate the Model Checking Driven Development process,
   - present a representation of the system in Maude,
   - perform LTL model checking on our model in Maude,
   - provide a client as an extension for Emacs,
   - provide an implementation of the server-side algorithm in Clojure.

* Formal Semantics of Editing Operations

  #+BEGIN_EXPORT latex
  \begin{wrapfigure}[14]{r}{0pt}
    \begin{tikzpicture}[>=stealth, shorten >= 5pt, node distance=1em, scale=1]
        \tikzstyle{vertex} = [circle, scale=0.5]
        \tikzstyle{O_0} = [vertex, fill=black!30!green]
        \tikzstyle{O_1} = [vertex, fill=black!30!blue]

        \tikzstyle{to} = [-{Stealth[scale=1.2]}]
        \tikzstyle{toO_0} = [to, color=black!30!green]
        \tikzstyle{toO_1} = [to, color=black!30!blue]

        \tikzstyle{op} = [midway, above=-3pt, sloped, text=black, font=\small]

        %% Server receives operations in this order
        \node[color=black!20] (s) at (3, 3.5) {$S$};
        \coordinate (se) at (3, 0) {};
        \node[O_0, color=black!20, below = 2em of s] (s1) {};
        \node[O_1, color=black!20, below = 1.5em of s1] (s2) {};

        %% User 0 generates/receives in this order
        \node (u0) at (0, 3.5) {$u_0$};
        \node (u0e) at (0, 0) {};
        \node[O_0, below = of u0, label=left:{\texttt{a}}] (u00) {};
        \node[O_1, above = 2em of u0e, label=left:{\texttt{ba}}] (u01a) {};

        \begin{pgfonlayer}{bg} % select the background layer
          \draw[to, color=black!20] (s) -- (s1)  -- (s2) -- (se);
          \draw[to, color=black!30] (u0) -- (u00) -- (u01a) -- (u0e);

          % Life of O_0
          \draw[toO_0] (u00) -- (s1) node [op] {$\overbrace{\ins{0}{a}}^{O_0}$};

          % Life of O_1
          \draw[toO_1] (s2) -- (u01a) node [op] {$\overbrace{\ins{0}{b}}^{O_1}$};
        \end{pgfonlayer}
    \end{tikzpicture}
    \caption{Our focus is on the operations of a single user.}
    \label{fig:focusclient}
  \end{wrapfigure}
  #+END_EXPORT

  A model of a given system is an abstraction of that system cite:Lamport:2002,
  which means only some aspects of the system are described. In our case, the
  fundamental capabilities of a text editor, namely the insertion and
  deletions of characters in a buffer, should be captured, along with the order
  in which they are performed. The time between operations is an example of
  something /not/ represented in the model; as a result the model cannot be
  used to analyze the real time performance of the system. Other features of a
  text editor, like "search and replace", are also omitted, because such
  features can be represented as a series of deletions and insertions.

  In this chapter we introduce a formal definition of editing operations. The
  definitions are based on
  cite:ellis1989concurrency,DBLP:journals/corr/abs-1302-3292, but we provide
  more mathematical definitions in the sense that the semantics of editing
  operations are described as a set of equations. This chapter is only
  concerned with events at a single client. We assume that every event is
  simply an operation being applied, and we will not differ between an
  operation originating locally or remotely.

** Operations and Buffers

   The operations we are concerned with is the /insertion/ and /deletion/ of a
   character in a buffer. Formally, we define the set of operations $\mathcal
   O$ as:
   - $nop \in \mathcal O$,
   - $ins(i, c) \in \mathcal O$ for any $i \in \mathbb{N}$ and $c \in Unicode$,
   - $del(i) \in \mathcal O$ for any $i \in \mathbb{N}$,
   - for any two $O_i, O_j \in \mathcal O$ then $O_j \circ O_i \in \mathcal O$,
   - $\mathcal O$ is closed under $\circ$.

   The semantics of an operation is defined in terms of how it is applied to a
   buffer, where a buffer is simply defined as a 0-indexed string of UTF-8
   encoded characters. The set $Unicode$ is our alphabet, which contains every
   character defined by the Unicode standard. We let $\mathcal B$ constitute
   the set of all possible buffers --- this set could also be expressed as
   $Unicode^{*}$.

   An operation can be applied to a buffer, which in turn yields a new buffer.
   Consequently all $O \in \mathcal O$ are partial unary operations $O :
   \mathcal B' \rightarrow \mathcal B$, where $\mathcal B' \subseteq \mathcal
   B$.

   Let $B \in \mathcal{B}$. The $nop$ operation is the operation that does
   nothing, and applying it is defined as:
   #+BEGIN_EXPORT latex
     \begin{align*}
       nop(B) &= B
     \end{align*}
   #+END_EXPORT
   Let $i \in \mathbb{N}$, and both $c, c' \in Unicode$. We let a single space
   represent concatenation, where characters are treated like strings of length
   one. Applying an insertion is then defined as follows:
   #+BEGIN_EXPORT latex
     \begin{align*}
       ins(0, c)(B) &= c\ B \\
       ins(i + 1, c)(c'\ B) &= c'\ ins(i, c)(B)
     \end{align*}
   #+END_EXPORT
   Similarly, applying a deletion is defined as:
   #+BEGIN_EXPORT latex
   \begin{align*}
     del(0)(c\ B) &= B \\
     del(i + 1)(c\ B) &= c\ del(i)(B)
   \end{align*}
   #+END_EXPORT
   Let $O_i, O_j \in \mathcal O$, and let $O_j \circ O_i$ represent the
   /composition/ of $O_i$ and $O_j$. Applying a composed operation to a buffer
   is defined as so:
   #+BEGIN_EXPORT latex
   \begin{align*}
     O_j \circ O_i(B) &= O_j(O_i(B))
   \end{align*}
   #+END_EXPORT
   Note that composition of operations is no different from regular function
   composition.

** Scenarios Described in Terms of Operations and Their Application

   In the previous section we formalized
   - what operations are,
   - how operations are applied to buffers, and
   - how operations are combined.

   Let us try to bridge the gap between the formal notion of an editing
   operation, and scenarios that involves a user typing on a keyboard. Imagine
   that a user types the word ~"hello"~ --- this is modeled as a single
   operation:
   \[ \ins{4}{o} \circ \ins{3}{l} \circ \ins{2}{l} \circ \ins{1}{e} \circ \ins{0}{h} \]
   The result of applying the operation to the empty buffer $\epsilon$
   evaluates to the buffer that only contains the word ~"hello"~, and can be
   calculated as so:
   #+BEGIN_EXPORT latex
   \begin{align*}
     \ins{4}{o} \circ \ins{3}{l} \circ \ins{2}{l} \circ \ins{1}{e} \circ \ins{0}{h} (\epsilon) &= \\
     \ins{4}{o} \circ \ins{3}{l} \circ \ins{2}{l} \circ \ins{1}{e} (\texttt{"h"}) &= \\
     \ins{4}{o} \circ \ins{3}{l} \circ \ins{2}{l} (\texttt{"he"}) &= \\
     \ins{4}{o} \circ \ins{3}{l} (\texttt{"hel"}) &= \\
     \ins{4}{o} (\texttt{"hell"}) &= \texttt{"hello"}
   \end{align*}
   #+END_EXPORT
   Now we will expand from the case where a single user types on a keyboard,
   and include operations that can be received from a server. In the scenario
   best described by Figure [[ref:fig:noconflict0]] (page pageref:fig:noconflict0),
   we saw two operations $\ins{0}{a}$ and $\ins{0}{b}$, named $O_0$ and $O_1$
   respectively, being applied in the same order at two different locations.
   #+BEGIN_EXPORT latex
   \begin{multicols}{2}
     From the perspective of $u_0$:
     \begin{itemize}
     \item $O_0$ is generated locally,
     \item $O_1$ is received from the server.
     \end{itemize}
     \columnbreak
     From the perspective of $u_1$:
     \begin{itemize}
     \item $O_0$ is received from the server,
     \item $O_1$ is generated locally.
     \end{itemize}
   \end{multicols}
   #+END_EXPORT
   Common to both $u_0$ and $u_1$ is their initial buffer (the empty buffer
   $\epsilon$) and the operation they apply is $O_1 \circ O_0$. Because they
   perform the same operation to the same initial buffer, they must necessarily
   end up in a consistent state (i.e. end up with the same buffer).

   The scenario from Figure [[ref:fig:conflict0]] (page pageref:fig:conflict0) is
   almost identical to the scenario above, but the operations are applied in
   different orders.
   #+BEGIN_EXPORT latex
   \begin{multicols}{2}
     From the perspective of $u_0$:
     \begin{itemize}
     \item $O_0$ is generated locally,
     \item $O_1$ is received from the server.
     \end{itemize}
     \columnbreak
     From the perspective of $u_1$:
     \begin{itemize}
     \item $O_1$ is generated locally,
     \item $O_0$ is received from the server.
     \end{itemize}
   \end{multicols}
   #+END_EXPORT
   $u_0$ and $u_1$ have the same initial buffer, but the composed operation of
   $u_0$ is $O_1 \circ O_0$ and the composed operation of $u_1$ is $O_0 \circ
   O_1$. By applying these operations to the empty buffer $\epsilon$ we show
   that $u_0$ and $u_1$ end up in an inconsistent state (i.e. end up with
   different buffers).
   #+BEGIN_EXPORT latex
   \begin{multicols}{2}
     Operation applied by $u_0$:
     \begin{align*}
       \overbrace{\ins{0}{b}}^{O_1} \circ \overbrace{\ins{0}{a}}^{O_0}(\epsilon) &= \\
       \ins{0}{b}(\texttt{"a"}) &= \texttt{"ba"}
     \end{align*}

     \columnbreak
     Operation applied by $u_1$:
     \begin{align*}
       \overbrace{\ins{0}{a}}^{O_0} \circ \overbrace{\ins{0}{b}}^{O_1}(\epsilon) &= \\
       \ins{0}{a}(\texttt{"b"}) &= \texttt{"ab"}
     \end{align*}
   \end{multicols}
    #+END_EXPORT

** Algebraic Properties

   An algebraic structure is a set along with one or more operations
   cite:antonsen2014logiske. The set of operations $\mathcal O$ under
   composition $\circ : \mathcal O \times \mathcal O \rightarrow \mathcal O$
   forms an algebraic structure, denoted $\langle \mathcal O, \circ \rangle$.

   The previous section contains a proof that $\circ$ is /not/ commutative,
   meaning that $O_j \circ O_i = O_i \circ O_j$ is not the case for all $O_i,
   O_j \in \mathcal O$.
   \begin{proof}
   As examplified in the previous section:
   \[
   ins(0, b) \circ ins(0, a) \neq ins(0, a) \circ ins(0, b)
   \]
   \end{proof}

   The fact that $\circ$ is not commutative is precisely the problem with a
   naïve algorithm (Section [[A Naïve Algorithm]]); in other words, a naïve
   algorithm would guarantee eventual consistency if the order of which
   operations are applied does not affect the end result.

   Furthermore, it is worth noting that the structure $\langle \mathcal O,
   \circ \rangle$ is a /monoid/ because it satisfies the following properties:

   - $nop$ is the identity element of $\circ$.
     \begin{proof}
     Let $O \in \mathcal O$, then
     \begin{itemize}
       \item $nop \circ O(B) = nop(O(B)) = O(B)$
       \item $O \circ nop(B) = O(nop(B)) = O(B)$
     \end{itemize}
     for any $B \in \mathcal B$. It follows that $nop \circ O = O \circ nop = O$.
     \end{proof}
   - $\circ$ is associative.
     \begin{proof}
     Let $O_i, O_j, O_k \in \mathcal O$, then
     \begin{itemize}
       \item $((O_k \circ O_j) \circ O_i)(B) = (O_k \circ O_j)(O_i(B)) = O_k(O_j(O_i(B)))$
       \item $(O_k \circ (O_j \circ O_i))(B) = O_k((O_j \circ O_i)(B)) = O_k(O_j(O_i(B)))$
     \end{itemize}
     for any $B \in \mathcal B$. It follows that $O_k \circ (O_j \circ O_i) =
     (O_k \circ O_j) \circ O_i$.
     \end{proof}
   - $\circ$ is closed under $\mathcal O$.
     \begin{proof}
     By definition.
     \end{proof}

   There are two main reasons for noting these algebraic properties; one is
   that it is helpful when writing a formal specification in Maude; the other
   is that it helps when translating the structure to a given programming
   language, by making sure the selected representation preserves the
   properties of a monoid.



#+LaTeX:\appendix
* LISP In Summer Projects contribution

   The following is the project description submitted for the LISP In Summer
   Projects contest.

** Purpose

    # What is your project? In about 50 words, describe your project.

    Shared buffer is a project that enables real-time collaborative editing in
    Emacs. It is split up in two parts, client and server. The client is an
    Emacs extension entirely written in Emacs Lisp. The server is a small
    Common Lisp program; there is currently a server running on 'virvel.de'.

** Function

    # What does your project do? In about 50 words, describe what your project
    # does.

    In Emacs one is simply able to share a buffer and connect to a buffer that
    is already shared. This is done by requesting a connection to a shared
    buffer server. Once a connection is established all changes in your buffer
    is sent to the server. The server simply redirects these messages to all
    Emacs clients connected to that shared buffer.

** Motivation

    # Why did you choose this project?  In about 50 words, describe what was
    # your motivation was for doing this particular project?

    Working on a small scale project with friends, fellow students and
    coworkers was not simple enough to do with Emacs. Having recently started
    learning Lisp, it seemed like a fun and ambitious project.

** Audience

    # Who did you write this for? In about 50 words, describe the intended
    # target audience and anticipated users.

    Initially me, and whomever I wanted to work with. After realizing I’d
    might actually make it work, I think it can be useful for anyone using
    Emacs in collaboration with others. It is written with small scale
    software projects in mind, but can be used for all kinds of text editing.

** Methodology

    # How does it work?  In about 300-400 words, describe the technical details
    # of how your software works.  This might include high-level algorithms, the
    # technical stack and technical or social challenges you faced.

    The project is divided into two parts, a client and a server. The server
    is written in Common Lisp, and it's main job is to allow the clients to
    communicate. The client is an Emacs extension written in Emacs Lisp which
    mainly send changes to the server, or receives changes from the server.

    The client may ask to establish a new session or connect to an existing
    one. If a new session is required, the client provides a key. This key is
    used by the server as key in a hash table, containing lists of clients. A
    client asking to connect to a shared buffer is simply added to the list of
    clients that corresponds to the given key.

    When a new client connects to an already established session, a single
    client is asked by the server to send it's entire buffer content. This
    package is marked as being for new clients only. From that point on they
    should keep synced. The session is kept alive as long as there are clients
    connected to it.

    The main challenge in this project was to figure out how to keep several
    separate Emacs buffers mirrored. This is resolved by sending a message for
    every command a user invokes (this is done by adding functions to
    after-change-hook and post-command-hook, both built-in variables in
    Emacs). These messages will dictate a change that happened in a
    buffer. Assuming the shared buffers are identical to the one sending the
    message prior of that change, we can safely apply that change to any
    client that receives this message.

    A problem arises if our assumption is wrong. The most common situation is
    that a client has made changes in a buffer between the time the message
    was sent and received. The point where the change should be applied is
    then calculated by using the difference in the size of the buffer the
    message was sent from, and the size of the buffer receiving the
    message. This works in most cases.

** Conclusion

    # In 100-200 words, clearly summarize both the accomplishments and
    # limitations of your software.  Describe future directions for your
    # projects. This can include enhancements as well as extensions.

    After a summers worth of coding I am glad to say that the core
    functionality is up and running. It is fast and lightweight. A lot of time
    has gone into finding the /right/ solution to the big problems, and
    finding good workarounds for Emacs's many idiosyncrasies. I believe the
    project has great potential.

    The main issue that needs fixing is how to detect and resolve problems
    with synchronization. As of now, once buffers go out of sync, there is
    really no other solution than to disconnect and reconnect. There are also
    quite a few bugs triggered by Emacs's many features and extensions, and
    I'm hoping to resolve these after the competition is over.

    I plan to make Shared buffer more user friendly, by supplying a Emacs
    minor mode accompanied by a chat feature. When these things are in order
    it will be released in [[http://melpa.milkbox.net/][melpa]], and will hopefully be found useful.

#+LaTeX:\backmatter{}
#+LaTeX:\printbibliography
* COMMENT Local variables
# Local Variables:
# eval: (require 'org-ref)
# org-ref-pdf-directory: "~/Dropbox/ifi/master/articles/"
# dabbrev-check-all-buffers: nil
# eval: (server-start)
# eval: (add-hook 'after-save-hook 'org-latex-export-to-latex nil t)
# eval: (compile "latexmk -pdf -pvc -pdflatex='pdflatex -shell-escape -interaction nonstopmode'")
# End:
