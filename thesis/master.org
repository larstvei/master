#+OPTIONS: num:3 H:5

#+BIND: org-latex-title-command ""
#+BIND: org-latex-toc-command ""

#+LaTeX_CLASS: ifimaster
#+LaTeX_CLASS_OPTIONS: [USenglish]

#+LATEX_HEADER: \usepackage[backend=biber,bibencoding=utf8]{biblatex}
#+LATEX_HEADER: \usepackage{parskip, inconsolata}
# #+LATEX_HEADER: \usepackage[Sonny]{fncychap}
#+LaTeX_HEADER: \urlstyle{sf}
#+LATEX_HEADER: \bibliography{ref}

#+TITLE: Collaborative editing in Emacs
#+AUTHOR: Lars Tveito
#+EMAIL: larstvei@ifi.uio.no

#+LaTeX: \ififorside{}
#+LaTeX: \frontmatter{}
#+LaTeX: \maketitle{}

#+BEGIN_abstract
Placeholder for abstract.
#+END_abstract

#+LaTeX: \tableofcontents{}
#+LaTeX: \listoffigures{}
#+LaTeX: \listoftables{}

#+LaTeX: \mainmatter{}

* TODO Introduction
** TODO Problem statement


   The goal is to implement real-time collaborative editing in Emacs. 
   Collaborative editing is a form of groupware \cite{ellis-ot}...

   We will focus on developing a sound protocol for real-time collaboration,
   which is to be minimal, and optimized for software development. To
   determine whether or not the protocol is sound, we want model it, and
   verify it using a tool for model checking.

   # In order to achieve this we want to describe the problem formally.
   
** Tools

   For any software project, some reflection around the tools that will help
   you build the software can be a huge time-saver down the road.

*** Client side language

    On the client side we are quite limited in our choice. We are targeting
    Emacs, which is a very extendable piece of software. At it's core Emacs
    is simply a /Lisp interpreter/, more specifically an interpreter for
    /Emacs Lisp/. As a consequence, anything that can be expressed in Emacs
    Lisp can be implemented in Emacs.

    Seeing that Emacs can communicate with external processes, we /could/ try
    to implement something in another language and use Emacs Lisp to
    communicate with the external process this program. This approach is
    mainly used for communicating with an interpreter for another language,
    in order to provide a good development environment for that particular
    language (some examples are SLIME, Cider, Geiser and jedi). However, the
    vast majority of extensions for Emacs are written solely in Emacs Lisp,
    because of its tight integration with Emacs.

    What we will need from our language is being able to change the state of
    an Emacs buffer, as well as communicating with network processes. Emacs
    Lisp fulfills these needs; it is excellent at working with Emacs
    buffers, and can also communicate with network processes. We will be
    using a library for /websockets/ for our network communication; a choice
    that will be discussed more in depth in the next section.

    Supporting other editors or IDE's than Emacs is an ambition of this
    project; we would have to reflect in a similar manner if we were to
    target other editors/IDE's. For instance, if we were to support a
    web-based editor we would be limited to using Javascript, or some
    language that compiles to Javascript, seeing that it is the only
    language that is supported naively in a browser.

*** Server side language

    In choosing a language for the client-side of program we found ourselves
    having very few options. Writing software that is to run on a server is
    a completely different story. The only fundamental requirement is that
    the language is able to host a network process, a requirement that is
    fulfilled by essentially all modern programming languages. So we can use
    any language we are likely to consider\cite{graham2004hackers}.

    This is a wonderful freedom, but it does require some more reflection
    around what language best suites our problem. An additional factor is
    what languages the programmers that are to implement the program are
    comfortable with.

    Whatever language we choose should let us reason over the programs
    produced. What I mean by this is that we should be able to go from a
    formal description of a solution to a program that implements this
    solution. Functional languages has proven far easier to reason over,
    because everything is expressed as /functions/, where we stay true to
    the mathematical definition of a function. Because functions are a
    mathematical construction, we can be very precise in what we express. In
    an imperative language, we would have to explicitly argue that some
    procedural construct represents our function.

    We will be dealing with concurrency; the server must deal with multiple
    clients simultaneously, that interact with multiple collections. To
    introduce state in a concurrent system requires /locking/; which is a
    voluntary act by the programmer. In other words, the language will not
    enforce locking, so it is up to the programmer to make the program
    thread-safe. By choosing a language that somehow enforces thread-safety,
    we have effectively outsourced this task to the language, and can trust
    our program is thread-safe from the fact that it did not fail
    compilation.

    The language should also have libraries for high-level network
    programming, to be able to focus at the task at hand, and not having to
    re-implement solved problems.
    
    The languages that are up for consideration should be functional,
    enforce thread-safety and have high-level network communication
    libraries. /Erlang/ is such a language. It is functional, this implies
    that data is immutable and functions can be passed to other functions
    and can also be the return value of a function. Erlang is a highly
    concurrent language, and uses the Actor model. Processes in Erlang serve
    as the actors, and they may communicate by passing messages. An actor
    can respond to the message and spawn new actors. Erlang is mainly used
    for distributed systems, and has a nice collection of libraries for
    network programming. For our task Erlang seems to be the perfect choice,
    and we could stop reflecting on the choice of language.

    However, the programmer that is to implement the system (namely me) has
    no experience with the language. This is not an argument that throws
    Erlang out of consideration, but if we can find another language with
    similar capabilities, that the programmer already have some experience
    with, this would be favorable to Erlang.

    There is a fairly young programming language, appearing in 2007, called
    /Clojure/. It is not a language that the programmer have notable
    experience with, but the programmer do have experience with /Lisp/. As
    it turns out, Clojure is a Lisp. It is also built on the Java Virtual
    Machine, so some experience with Java would also be an
    advantage. Luckily, the programmer has some experience with Java as
    well. Se even without any direct experience with Clojure, we can expect
    the programmer to adapt this language in at a greater speed than
    Erlang.

    Now we want to argue that Clojure does suite the problem at
    hand. Clojure is /functional/, it is probably the most functional widely
    used /Lisp/ dialect. All Lisp's have functional capabilities, seeing
    that functions are first-class citizens, but the core data structures
    are not immutable; this means Lisp is functional by convention, meaning
    that one can choose to program functionally, but is not required
    to. Clojure is different in this respect, all the core data structures
    are persistent and immutable.  

    We will see that the persistent data structures in Clojure are a means
    to deal with concurrency. A persistent data structure will reuse as much
    as possible of previous versions of that same structure. The simplest
    example would be a list. The performance capabilities of a list is
    typically constant time insertion at the front, and linear time
    traversal. Given a list =(2 3)=, we can add some element, for instance
    =1= to the front of the list, resulting in a /new/ list =(1 2 3)=. If we
    had a reference to =(2 3)=, this new list would have no effect the
    reference. To make sure we keep constant-time performance on insertion,
    we do not want to copy the list =(2 3)=, rather we make our new list
    by keeping a reference to the list we extended. This is how Lisp lists
    are normally implemented, but if we don't enforce immutability this
    can lead to unexpected results. Say we have a reference $a$ to =(2 3)=,
    and a reference $b$ to the new list =(1 2 3)=. If we destructively
    change the list referenced by $b$ to =(1 2 1)=, we would effectively
    change the list referenced by $a$ to =(2 1)=. This poses a problem for
    concurrency, because the data we work on can be changed from underneath
    us by some other process or thread.

    All Clojure data structures are persistent, these include /sets/,
    /vectors/ and /maps/. We will briefly look into maps, seeing that they
    are conceptually very similar to vectors, the only difference is that
    vector associates a index with some piece of data, whilst maps associate
    any piece of data with some other piece of data.

* TODO Existing solutions
* TODO Algorithm and protocol
** The /Shared Buffer/ protocol

   

** TODO Verification of the algorithm

   The three clients all adds a character at the start of the buffer
   simultaneously. Let T_n represent a step in time. The ~expected-seqno~
   represents the global sequence number at the server, and ~ops~ represent
   stored operations.

   | T_n | recv,seqno | expected-seqno | ops   | client 1 | client 2 | client 3 |
   |-----+------------+----------------+-------+----------+----------+----------|
   | T_0 |            |              1 |       | a        | b        | c        |
   | T_1 | a,1        |              1 | a     |          |          |          |
   | T_2 |            |              2 | a     | a        | ab       | ac       |
   | T_3 | b,1        |              2 | a,b   | a        | ab       | ac       |
   | T_4 |            |              3 | a,b   | b        | ab       | c        |
   | T_5 |            |              3 | a,b   | ab       | ab       | bc       |
   | T_6 |            |              3 | a,b   | ab       | ab       | abc      |
   | T_7 | c,1        |              3 | a,b,c | ab       | ab       | abc      |
   | T_8 |            |              4 | a,b,c | c        | c        | abc      |
   | T_9 |            |              4 |       | abc      | abc      | abc      |


** TODO Implementation of the algorithm
* TODO Concluding remarks

#+LaTeX: \backmatter{}
#+LaTeX: \printbibliography
