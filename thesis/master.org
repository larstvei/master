#+TITLE: Specification, Verification and Implementation of a Real-Time Collaborative Editing Protocol
#+AUTHOR: Lars Tveito
#+EMAIL: larstvei@ifi.uio.no
#+OPTIONS: num:3 H:5 todo:nil title:nil toc:nil
#+LaTeX_CLASS_OPTIONS: [USenglish]
#+LaTeX_CLASS: ifimaster
#+LATEX_HEADER: \usepackage[backend=biber,bibencoding=utf8]{biblatex}
#+LATEX_HEADER: \usepackage{parskip, inconsolata}
#+LATEX_HEADER: \bibliography{ref}
#+LaTeX_HEADER: \urlstyle{sf}

#+LaTeX: \ififorside{}
#+LaTeX: \frontmatter{}
#+LaTeX: \maketitle{}

#+BEGIN_abstract
Placeholder for abstract.
#+END_abstract

#+LaTeX:\chapter*{Acknowledgments}

Thanks to Rudi and Martin, Tore, Sigurd, Carl Martin, Joshi, Fui, Sigmund,
Jonny, Simen, my family, and so many more.

#+LaTeX:\chapter*{Preface}
In 2013 [[http://lispnyc.org][LispNYC]], [[http://www.meetup.com/Clojure-NYC/][ClojureNYC]] and [[http://alu.org][Association of Lisp Users]] hosted a programming
competition called [[http://lispinsummerprojects.org/][LISP In Summer Projects]], awarding cash prizes for
Lisp-related projects. They gathered some great finalist judges: Matthias
Felleisen, Richard Gabriel, Rich Hickey, Peter Norvig, Christian Queinnec and
Taiichi Yuasa.

Around the time of the announcement of the competition, I attended a course on
functional programming, in which we were to collaborate on programming
assignments in small teams (of two or three participants). Mostly, we
programmed together whilst in the same room (physically), and at any given
moment, the one with the most promising idea held the keyboard. Sometimes we
all wanted to explore some idea, and we would have to type it out on separate
computers, and synchronize our changes thereafter.

At times we (or at least I) felt it broke our flow. I started investigating how
to allow separate Emacs sessions communicate using network processes, and
realized it was completely plausible to enable real-time collaboration in
Emacs.

Seeing the aforementioned competition announcement, I immediately decided that
implementing real-time collaboration in Emacs would make the perfect project.

My approach was quite naive, and it was developed in a "Ha! Now it seems to
work!"-fashion. By the end of the summer I had a rough prototype that worked
for what I deemed "the most common use-cases". It had a very serious problem:
All changes were applied under the assumption of consistency between clients,
but this assumption proved false in non-trivial use-cases. There was no
recovery mechanism in place, and if consistency was breached, then it would be
up to the /user/ to detect this, and reconnect.

Still, the judges of the competition deemed the program worthy of second prize,
awarding me 500$ for my efforts.

It was by far the most ambitious project I've embarked on, and also the most
rewarding. I was greatly honored for receiving the prize, and feel my gratitude
should be expressed in /elegant/ Lisp code, that compose a working
implementation of the program I wished I had written back in 2013.


#+LaTeX: \tableofcontents{}
#+LaTeX: \listoffigures{}
#+LaTeX: \listoftables{}
#+LaTeX: \mainmatter{}

#+LaTeX: \renewcommand\href[2]{#2\footnote{\url{#1}}}

* TODO Introduction
** TODO Motivation

** TODO Problem Statement

   Summarized to one sentence the problem can be stated as such:

   #+BEGIN_QUOTE
   The task is to specify, verify and implement a minimal network protocol
   that enables real-time collaborative editing in existing text editors.
   #+END_QUOTE

** TODO Background and Related Work
** TODO Outline of the Thesis
* TODO Formal Specification and Verification
** TODO Formal Methods and Model Checking
** TODO An informal Protocol Specification
** TODO Formalizing the Specification
** TODO Modeling the Specification in Maude
** TODO Specifying the System Properties using LTL
** TODO Verifying Properties using the Maude LTL-checker
* TODO Design and Implementation
** TODO Design Goals
** TODO Design Principles
** TODO Ensuring Portability
** TODO Languages and Tools
** TODO Server-side: Implementation of the Specification in Clojure
** TODO Client-side: Implementing a client in Emacs
* TODO Concluding remarks
** TODO The Caveats of the Resulting implementation
** TODO Noteworthy Results
** TODO The Influence of having a Formal Specification
** TODO Public Reception
** TODO Final Remarks and Future Work

 #+LaTeX: \backmatter{}
 #+LaTeX: \printbibliography

#+LaTeX:\appendix

* LISP In Summer Projects contribution

   The following is the project description submitted for the LISP In Summer
   Projects contest.

** Purpose

    # What is your project? In about 50 words, describe your project.

    Shared buffer is a project that enables real-time collaborative editing in
    Emacs. It is split up in two parts, client and server. The client is an
    Emacs extension entirely written in Emacs Lisp. The server is a small
    Common Lisp program; there is currently a server running on 'virvel.de'.

** Function

    # What does your project do? In about 50 words, describe what your project
    # does.

    In Emacs one is simply able to share a buffer and connect to a buffer that
    is already shared. This is done by requesting a connection to a shared
    buffer server. Once a connection is established all changes in your buffer
    is sent to the server. The server simply redirects these messages to all
    Emacs clients connected to that shared buffer.

** Motivation

    # Why did you choose this project?  In about 50 words, describe what was
    # your motivation was for doing this particular project?

    Working on a small scale project with friends, fellow students and
    coworkers was not simple enough to do with Emacs. Having recently started
    learning Lisp, it seemed like a fun and ambitious project.

** Audience

    # Who did you write this for? In about 50 words, describe the intended
    # target audience and anticipated users.

    Initially me, and whomever I wanted to work with. After realizing Iâ€™d
    might actually make it work, I think it can be useful for anyone using
    Emacs in collaboration with others. It is written with small scale
    software projects in mind, but can be used for all kinds of text editing.

** Methodology

    # How does it work?  In about 300-400 words, describe the technical details
    # of how your software works.  This might include high-level algorithms, the
    # technical stack and technical or social challenges you faced.

    The project is divided into two parts, a client and a server. The server
    is written in Common Lisp, and it's main job is to allow the clients to
    communicate. The client is an Emacs extension written in Emacs Lisp which
    mainly send changes to the server, or receives changes from the server.

    The client may ask to establish a new session or connect to an existing
    one. If a new session is required, the client provides a key. This key is
    used by the server as key in a hash table, containing lists of clients. A
    client asking to connect to a shared buffer is simply added to the list of
    clients that corresponds to the given key.

    When a new client connects to an already established session, a single
    client is asked by the server to send it's entire buffer content. This
    package is marked as being for new clients only. From that point on they
    should keep synced. The session is kept alive as long as there are clients
    connected to it.

    The main challenge in this project was to figure out how to keep several
    separate Emacs buffers mirrored. This is resolved by sending a message for
    every command a user invokes (this is done by adding functions to
    after-change-hook and post-command-hook, both built-in variables in
    Emacs). These messages will dictate a change that happened in a
    buffer. Assuming the shared buffers are identical to the one sending the
    message prior of that change, we can safely apply that change to any
    client that receives this message.

    A problem arises if our assumption is wrong. The most common situation is
    that a client has made changes in a buffer between the time the message
    was sent and received. The point where the change should be applied is
    then calculated by using the difference in the size of the buffer the
    message was sent from, and the size of the buffer receiving the
    message. This works in most cases.

** Conclusion

    # In 100-200 words, clearly summarize both the accomplishments and
    # limitations of your software.  Describe future directions for your
    # projects. This can include enhancements as well as extensions.

    After a summers worth of coding I am glad to say that the core
    functionality is up and running. It is fast and lightweight. A lot of time
    has gone into finding the /right/ solution to the big problems, and
    finding good workarounds for Emacs's many idiosyncrasies. I believe the
    project has great potential.

    The main issue that needs fixing is how to detect and resolve problems
    with synchronization. As of now, once buffers go out of sync, there is
    really no other solution than to disconnect and reconnect. There are also
    quite a few bugs triggered by Emacs's many features and extensions, and
    I'm hoping to resolve these after the competition is over.

    I plan to make Shared buffer more user friendly, by supplying a Emacs
    minor mode accompanied by a chat feature. When these things are in order
    it will be released in [[http://melpa.milkbox.net/#/][melpa]], and will hopefully be found useful.
