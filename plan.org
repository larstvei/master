* Plan
** First semester
*** INF4130
*** INF4820
*** INF5780
** Second semester
*** INF5140
*** INF5510
*** Essay (10 pts)
** Third semster
*** INF5750
*** Master (20 pts)
** Fourth semester
*** Master (30 pts)
* Thesis
** Tasks
*** DONE Implement an echo server in Clojure using websocket
*** DONE Make Emacs connect to the echo server using websocket
*** TODO Send changes to the server form Emacs
*** TODO Make server sync the Emacs buffer
** Implementation goals
*** A sound protocol for real-time collaboration in Emacs
*** Server should be written in functional style using Clojure
*** Minimize client, making expansion to other editors trivial
*** Prove soundness of protocol
*** Make it fast
*** Make it secure
*** Integration with source control (git)
** Thesis goals
*** Clear problem statement

    The thesis will focus on enabling real-time collaboration for software
    projects. More specifically we will focus on developing a sound protocol
    for real-time collaboration, which is to be minimal, and optimized for
    software development. In order to narrow the scope we will focus on
    enabling this feature in Emacs.

    This is not an unsolved problem, but there are no widespread usage of
    any current solution (for Emacs). Why this is will be discussed
    further. A solution for Emacs is, however, not the goal in itself, only
    a stepping stone towards it. The solution implemented should not be in
    any way limited to Emacs; it should be a generalized solution which
    support any client that satisfies the protocol.

    There are at the moment several solution for real-time collaboration,
    these include Google Drive, ShareLaTex, Etherpad, SubEthaEdit and
    Stypi. These cover different needs; Google Drive is mainly for creating
    documents (in a style not unlike Word); ShareLaTeX is tailored for
    LaTeX; Etherpad is a document editor that is open source and
    customizable; SubEthaEdit is for collaborative coding; Stypi is a online
    text editor.

    In this collection SubEthaEdit stands out as a product which is close to
    our goal, which is to enable real-time collaboration for software
    projects. This is however limited to the Mac OS X platform, and is under
    a proprietary license. A similar editor, Gobby, is open source and uses
    the Obby protocol.

    Gobby comes very close indeed. There even exists an Emacs extension
    called Rudel which uses this protocol. Rudel is seemingly abandonware,
    seeing that there has been no activity on their mailing list since 2011.

    The Rudel code base consists of more than 16000 lines of
    code[fn:1]. This poses a potential problem for widespread use;
    developers gravitate towards different tools (or their work drags them
    in a particular direction), so having the tool available on a variety of
    platforms seems paramount. Perhaps if the protocol requires a
    significantly smaller implementation, widespread usage is feasible.

*** Discuss different approaches 
**** P2P vs Server & Client
**** Other solutions
***** What does Shared Buffer provide that lacks in other solutions?
***** Discuss Google drive/docs/wave
***** ShareLaTex
***** Discuss Rudel
***** Discuss Etherpad
***** Discuss Stypi
***** Discuss SubEthaEdit
** Links
*** http://static.googleusercontent.com/media/research.google.com/no//pubs/archive/41895.pdf
*** P2P http://dl.acm.org/citation.cfm?id=1180916 [[file:p259-oster.pdf][lokal-pdf]]
*** Duplex http://dl.acm.org/citation.cfm?id=192900 [[file:p165-pacull.pdf][local-pdf]]
*** TLA+ http://research.microsoft.com/en-us/um/people/lamport/tla/formal-methods-amazon.pdf
*** Formal methods protocol testing http://www.csee.umbc.edu/courses/graduate/681/Fall07/formal_methods_protocol_testing.pdf
** Miscellaneous
*** Have INF2810 students test Share Buffer
* Other ideas for theis
** A new language
*** The StackOverflow structure
    Create a language which is at its core very (very) small. It won't have
    any libraries. No development will be done in the language; it has no
    central ownership, nor is it headed in any particular direction. Instead
    it will consist of small modules. Every module will automatically be
    available for everyone (maybe allow exceptions?). All modules will be
    searchable, and they can be up- and down-voted. Popular modules will
    greatly influence the language, and be present in a lot of programs. The
    users of the language decide what direction the language is headed, and
    they will participate implicitly by using modules.
*** http://www.chrisseaton.com/katahdin/katahdin.pdf
    
** A javascript markdown viewer
   Make an alternative markdown to html, and using javascript to typeset the
   document.

* Footnotes

[fn:1] Ran =find . -name "*.el" | xargs wc -l= in the Rudel base directory.

* Notes
** Things I find difficult
*** Deciding on structure
*** Avoiding "we"-form 
*** Avoid trailing off on something slightly beside the point
** Structure
*** Title
*** Abstract
*** Introduction
*** Methods
*** Results
*** Discussion
*** Conclusion
** Write down how you would explain your thesis to a 15 year old kid
   Making it possible for more than one person to work on the same code at
   the same time. Working on code is a lot like writing in a document, but
   we work with pure text (bla bla bla).
** 10 rules
*** Find out what you want to say using only one sentence
*** Know your target group
*** Do not assume that everyone interested, make them
*** Give your reader a good reason for reading your esay
*** Kill your darlings
*** Write as simple sentences as possible
*** Know why you are saying what you are saying where you are saying it
*** Show them, don't tell them
*** Know the difference between your goals and your means
*** Create flow and bridges between sentences, points and paragraphs
** Write down your essay question
*** How to make a (preferable proven) reliable and minimalistic protocol for collaborative editing.
*** How to design, implement and verify collaborative editing facilities in Emacs.
*** What is "operational transformation"?
*** Is a subset of the operational transformation adequate for sb?
*** Why not gobby/SubEthaEdit/Rudel?
*** Can I describe the program with temporal logic?
*** What is temporal logic?
*** Can the entire program be modeled and proved?
*** Can parts of the program be modeled and proved?
*** What is the smallest feature-set suitable for sb?
** Write down two to three sentences to introduce the context of your question

   There are several collaborative editing services in wide-spread use, like
   Google Docs. Still, there is no tool in wide-spread use to enable this
   feature for working with code. Developers tend to prefer combining
   several specialized (and preferably extendable) tools targeting a
   specialized task, over "one great tool" that does everything.

   How can one implement a simple enough tool to make enabling collaborative
   editing in existing code development tools? We'll target Emacs to narrow
   the scope of this thesis.

** The meta trap
   Skriv noe her...
** Introduction

   In the introduction the work of others is primary, and your work is
   secondary.

** Discussion

   In the introduction your work is primary, and the work of others is
   secondary.

*** How to build up an argument
**** A bad essay is one with long intro and no discussion.

** Establishing research territory
*** Establishing a niche
** When do I need a reference
*** When it is not your idea
*** When you need backup
*** When you are looking for supporting facts
*** When you need to show what is done before
*** When you need to show the "bricks"
*** When you need to show your actual contribution
** Write down your path of sub questions and give it to the person sitting next to you
*** How does one implement a minimal protocol for enabling collaborative editing?
*** How does one model the protocol?
*** Is this best represented as operational transformations?
*** What are a operational transform?
*** Is a subset of operational transform adequate for the task?
*** What modelling language is best suited for verifying a distributed system like this?
*** Can the algorithm be described with temporal logic?
*** What is temporal logic?
*** What is the minimal amount of information needed to keep a synchronized state?
*** What representation will be most likely to be supported in other text editors?
** Discussing your results
*** Discuss existing literature
*** Offering a general conclusion
*** Reminding the reader of the original purpose of the research
*** ...
** You and your language
*** Operates on three levels
**** Sentence
**** Paragraph
     Discuss only one point at a time, and tie the paragraphs together.
**** The whole essay
** Giving up your baby
*** Letting other people read your draft is crucial
*** Getting criticism is the best thing that can happen
*** How do you receive and give criticism the right way?
**** Receiving criticism
***** Criticism is help
***** If you have to explain what you mean - rewrite
***** If people don't understand, it's not them - it's you
***** Be grateful that people want to help you
**** How to edit texts
***** Why am I reading this?
***** Where do I fall off?
***** Is everything logical?
***** What questions do I get when reading it?
***** Do I like the writer?
***** Typos
** Writers block
*** It's a good thing - relax and do something else
*** Focus on what you know
*** Write down question you get when reading your draft
*** Write down thoughts and connections that are untied to the present structure of the essay
** The middle problems
*** What to do if you change your main question?
**** Not a disaster
*** Writing to much
**** Is everything relevant?
**** Have I written things twice?
*** Writing too little
**** Have you read enough?
**** Expand by
***** Exemplifying
***** Clarifying the meaning or the significance
***** Giving it more substance with further evidence
***** enhancing the importance of the information
