load model-checker

--- Redefine CONFIGURATION for format
mod CONFIGURATION is
    sorts Attribute AttributeSet .
    subsort Attribute < AttributeSet .
    op none : -> AttributeSet  [ctor] .
    op _,_ : AttributeSet AttributeSet -> AttributeSet
        [ctor assoc comm id: none format (d d ntsss d)] .

    --- Removed Msg
    sorts Oid Cid Object Portal Configuration .
    subsort Object Portal < Configuration .
    op <_:_|_> : Oid Cid AttributeSet -> Object [ctor object] .
    op none : -> Configuration [ctor] .
    op __ : Configuration Configuration -> Configuration
        [ctor config assoc comm id: none format (d nn d)] .
    op <> : -> Portal [ctor] .
endm

--- Likewise for MAP
fmod MAP{X :: TRIV, Y :: TRIV} is
  protecting BOOL .
  sorts Entry{X,Y} Map{X,Y} .
  subsort Entry{X,Y} < Map{X,Y} .

  op _|->_ : X$Elt Y$Elt -> Entry{X,Y} [ctor] .
  op empty : -> Map{X,Y} [ctor] .
  op _,_ : Map{X,Y} Map{X,Y} -> Map{X,Y} [ctor assoc comm id: empty prec 121 format (d r onttssss d)] .
  op undefined : -> [Y$Elt] [ctor] .

  var D : X$Elt .
  vars R R' : Y$Elt .
  var M : Map{X,Y} .

  op insert : X$Elt Y$Elt Map{X,Y} -> Map{X,Y} .
  eq insert(D, R, (M, D |-> R')) =
     if $hasMapping(M, D) then insert(D, R, M)
     else (M, D |-> R)
     fi .
  eq insert(D, R, M) = (M, D |-> R) [owise] .

  op _[_] : Map{X,Y} X$Elt -> [Y$Elt] [prec 23] .
  eq (M, D |-> R)[D] =
     if $hasMapping(M, D) then undefined
     else R
     fi .
  eq M[D] = undefined [owise] .

  op $hasMapping : Map{X,Y} X$Elt -> Bool .
  eq $hasMapping((M, D |-> R), D) = true .
  eq $hasMapping(M, D) = false [owise] .
endfm

fmod STR is
    sort Str .
    ops a b c d e f g h i : -> Str .
endfm

view Str from TRIV to STR is
    sort Elt to Str .
endv

fmod BUFFER is
    pr LIST{Str} .
    pr STR .

    sort Buffer .
    subsort List{Str} < Buffer .
endfm

fmod ERROR is
    pr BUFFER .

    sort Error .
    subsort Buffer < Error .

    op error : -> Error [format (r o)] .
endfm

mod UNIQUE is
    pr CONFIGURATION .
    pr LIST{Str} .

    sorts Unique .

    subsort Unique < Configuration .

    op [ _ ] : List{Str} -> Unique .
endm

mod ACTIONS is
    pr CONFIGURATION .
    pr NAT .

    sort Actions .
    subsort Actions < Configuration .

    op actions_ : Nat -> Actions .
endm

fmod USER is
    pr NAT .

    sort User .
    op user_ : Nat -> User .
endfm

view User from TRIV to USER is
    sort Elt to User .
endv

fmod ABSTRACT-OPERATION is

    sort Op .

    op nop : -> Op [ctor] .

    vars O O' O'' O''' : Op .

    op inv : Op -> Op .
    eq inv(nop) = nop .
    eq inv(inv(O)) = O .
    eq inv(O o O') = inv(O') o inv(O) .

    op _o_ : Op Op -> Op [assoc] .
    eq O o nop = O .
    eq nop o O = O .
    eq O o inv(O) = nop .
endfm

view Op from TRIV to ABSTRACT-OPERATION is
    sort Elt to Op .
endv

fmod INSERT-DELETE is
    pr ABSTRACT-OPERATION .
    pr NAT .
    pr STR .

    op ins : Nat Str -> Op [ctor format (g o)] .
    op del : Nat Str -> Op [ctor format (r o)] .

    var N : Nat .
    var S : Str .

    --- eq inv(ins(N,S)) = del(N,S) .
    --- eq inv(del(N,S)) = ins(N,S) .
endfm

fmod HISTORYITEM is
    pr BOOL .
    pr NAT .
    pr ABSTRACT-OPERATION .
    pr LIST{Op} .

    sort Hst .

    op __ : Op Nat -> Hst .

    vars O O' : Op .
    vars N N' : Nat .

    op _<_ : Hst Hst -> Bool .
    eq O N < O' N' = N < N' .
    --- eq ins(I,S) N < ins(I',S') N' = I < I' or (I == I' and N < N') .
    --- eq ins(I,S) N < del(I',S') N' = I < I' or (I == I' and N < N') .
    --- eq del(I,S) N < ins(I',S') N' = I < I' or (I == I' and N < N') .
    --- eq del(I,S) N < del(I',S') N' = I < I' or (I == I' and N < N') .
endfm

view Hst< from STRICT-TOTAL-ORDER to HISTORYITEM is
    sort Elt to Hst .
endv

fmod TRANSFORMATIONS is
    pr LIST{Op} .
    pr ABSTRACT-OPERATION .
    pr SORTABLE-LIST{Hst<} .

    vars O O' : Op .
    vars N N' : Nat .
    var H : List{Hst<} .

    op transform : List{Hst<} Hst -> Op .
    eq transform(nil, O N) = O .

    eq transform((O' N') H, O N) = O .

    --- eq transform(OS, O) = compose(OS) o O .
    --- eq transform(OS, O) = compose(OS) o O o compose(reverse(invert(OS))) .
    --- eq transform((Oj OS), Oi) = Oj o transform(OS, Oi) o inv(Oj) .

    --- op compose : List{Op} -> Op .
    --- eq compose(O) = O .
    --- eq compose(Oi Oj) = Oi o Oj .
    --- eq compose(Oi Oj OS) = Oi o Oj o compose(OS) .

    --- op invert : List{Op} -> List{Op} .
    --- eq invert(nil) = nil .
    --- eq invert(Oi OS) = inv(Oi) invert(OS) .
endfm

fmod APPLY is
    pr BUFFER .
    pr ERROR .
    pr INSERT-DELETE .

    vars Oi Oj : Op .
    vars S T : Str .
    var B : Buffer .
    var I : Nat .

    op apply_on_ : Op Buffer -> Buffer .
    eq apply nop on B = B .

    eq apply inv(ins(I,S)) on B = apply del(I,S) on B .
    eq apply inv(del(I,S)) on B = apply ins(I,S) on B .

    eq apply ins(0, S) on B = S B .
    eq apply ins(s I, S) on T B = T (apply ins(I, S) on B) .
    eq apply ins(s I, S) on nil = error .

    eq apply del(0, S) on S B = B .
    ceq apply del(0, S) on T B = error if S =/= T .
    eq apply del(s I, S) on T B = T (apply del(I, S) on B) .
    eq apply del(I, S) on nil = error .

    eq apply Oi o Oj on B = apply Oi on (apply Oj on B) .

    eq apply Oi on error = error .
endfm

fmod MSG is
    pr NAT .
    pr ABSTRACT-OPERATION .

    sort Msg .

    op msg : Op Nat Nat -> Msg .
endfm

view Msg from TRIV to MSG is
    sort Elt to Msg .
endv

mod SITE is
    pr CONFIGURATION .
    pr BUFFER .
    pr LIST{Msg} .
    pr MSG .
    pr ABSTRACT-OPERATION .
    pr USER .

    sort Site .
    subsort Site < Configuration  .

    op <_|_> : User AttributeSet -> Object [ctor object] .
    op buffer :_ : Buffer -> Attribute .
    op seqno :_ : Nat -> Attribute .
    op state :_ : Nat -> Attribute .
    op in-queue :_ : List{Msg} -> Attribute .
    op out-queue :_ : List{Msg} -> Attribute .
endm

mod SITE-RULES is
    pr ACTIONS .
    pr APPLY .
    pr BUFFER .
    pr LIST{Msg} .
    pr MSG .
    pr ABSTRACT-OPERATION .
    pr USER .
    pr UNIQUE .
    pr SITE .

    vars B B' B'' : Buffer .
    vars I I' N M : Nat .
    var Q : List{Msg} .
    var O : Op .
    var S : Str .
    var U : User .
    var A : AttributeSet .

    rl [user-inserts] :
        actions s M
        [ S B'' ]
        < U | buffer : (B B'), seqno : N, state : I, out-queue : Q, A >
      =>
        actions M
        [ B'' ]
        < U | buffer : (B S B'), seqno : s N, state : I,
        out-queue : (msg(ins(size(B), S), I, N) Q), A > .

    rl [user-deletes] :
        actions s M
        < U | buffer : (B S B'), seqno : N, state : I, out-queue : Q, A >
      =>
        actions M
        < U | buffer : (B B'), seqno : s N, state : I,
        out-queue : (msg(del(size(B), S), I, N) Q), A > .

    crl [user-receive] :
        < U | buffer : B, seqno : N, state : I, in-queue : (Q msg(O,I',N)), A >
      =>
        < U | buffer : B', seqno : s N, state : I', in-queue : Q, A >
      if B' := apply O on B .

    crl [user-receive-reject] :
        < U | buffer : B, seqno : N, in-queue : (Q msg(O,I',M)), A >
      =>
        < U | buffer : B, seqno : s N, in-queue : Q, A >
      if N =/= M .
endm

mod SITE-INFO is
    pr LIST{Op} .
    pr NAT .

    sort Siteinfo .
    --- [State, seqno, operations]
    op [_,_,_] : Nat Nat List{Op} -> Siteinfo .
endm

view Siteinfo from TRIV to SITE-INFO is
    sort Elt to Siteinfo .
endv

mod SERVER is
    pr CONFIGURATION .
    pr MAP{User,Siteinfo} .
    pr SITE-INFO .
    pr NAT .
    pr SORTABLE-LIST{Hst<} .

    op < server |_> : AttributeSet -> Object [ctor object] .
    op history :_ : List{Hst<} -> Attribute .
    op sites :_ : Map{User,Siteinfo} -> Attribute .
endm

mod MULTICAST is
    pr CONFIGURATION .
    pr LIST{Msg} .
    pr MAP{User,Nat} .
    pr MSG .
    pr ABSTRACT-OPERATION .
    pr SERVER .
    pr SITE-INFO .
    pr SITE .
    pr TRANSFORMATIONS .
    pr USER .

    sort Multicast .
    subsort Multicast < Configuration .

    op multicast_to_ : Op Map{User,Siteinfo} -> Multicast .

    var O : Op .
    vars OPS OPS' : List{Op} .
    var Q : List{Msg} .
    var U : User .
    vars A A' : AttributeSet .
    vars I N : Nat .
    vars US US' : Map{User,Siteinfo} .

    eq [multicast] : multicast O to empty = none .
    eq [multicast] :
        < U | in-queue : Q, A >
        < server | sites : (U |-> [I, N, OPS'], US'), A' >
        multicast O to (U |-> [I, N, OPS], US)
      =
        < U | in-queue : (msg(O, I, N) Q), A >
        < server | sites : (U |-> [I, s N, OPS'], US'), A' >
        multicast O to US .
endm

mod SERVER-RULES is
    pr CONFIGURATION .
    pr LIST{Msg} .
    pr MAP{User,Siteinfo} .
    pr MULTICAST .
    pr ABSTRACT-OPERATION .
    pr SERVER .
    pr SITE .
    pr SORTABLE-LIST{Hst<} .
    pr TRANSFORMATIONS .

    vars A A' : AttributeSet .
    vars Q Q' : List{Msg} .
    vars O O' : Op .
    vars I N N' S S' : Nat .
    var U  : User .
    var OPS : List{Op} .
    var H  : List{Hst<} .
    var US : Map{User,Siteinfo} .

    crl [server-receive] :
        < U | out-queue : (Q msg(O,S,N)), in-queue : Q', A >
        < server | history : H, state : I, sites : (U |-> [I, N', OPS], US), A' >
      =>
        < U | out-queue : Q, in-queue : (msg(O' o inv(O), s I, s N) Q'), A >
        < server | history : ((O I) H), state : s I, sites : (U |-> [S, S', (O OPS)], US), A' >
        multicast O to US
      if S' := s N + sd(size(H), N) /\ O' := transform(H, O S) .
endm

mod PREDICATES is
    pr CONFIGURATION .
    pr LTL-SIMPLIFIER .
    pr MODEL-CHECKER .
    pr SATISFACTION .
    pr SITE .

    subsort Configuration < State .

    ops consistent inconsistent : -> Prop .

    vars A A' : AttributeSet .
    vars B B' : Buffer .
    vars U U' : User .
    var C : Configuration .
    
    ceq < U  | buffer : B,  A  >
        < U' | buffer : B', A' >
        C |= inconsistent = true if B =/= B' .

    eq C |= inconsistent = false [owise] .

    eq C |= consistent = not C |= inconsistent .
endm

mod TEST is
    pr ACTIONS .
    pr APPLY .
    pr BUFFER .
    pr CONFIGURATION .
    pr ERROR .
    pr MSG .
    pr MULTICAST .
    pr ABSTRACT-OPERATION .
    pr PREDICATES .
    pr SERVER .
    pr SERVER-RULES .
    pr SITE .
    pr SITE-RULES .
    pr STR .
    pr TRANSFORMATIONS .
    pr UNIQUE .
    pr USER .

    op init  : -> Configuration .
    op init_ : Buffer -> Configuration .

    var C : Configuration .
    var I : Nat .
    var N : Nat .
    var N' : Nat .
    var O : Op .
    var OPS : List{Op} .
    vars Q Q' : List{Msg} .
    var U : User .
    var US : Map{User,Siteinfo} .
    vars A A' : AttributeSet .
    vars B B' B'' : Buffer .
    vars Oi Oj : Op .
    vars S T : Str .

    eq init = init nil .

    eq init B =
        [ a b c d ]
        actions 2
        < user 0 | buffer : B, seqno : 0, state : 0, out-queue : nil, in-queue : nil >
        < user 1 | buffer : B, seqno : 0, state : 0, out-queue : nil, in-queue : nil >
        < server | history : nil, state : 0,
                   sites : (user 0 |-> [0, 0, nil], user 1 |-> [0, 0, nil]) > .
endm

--- search init =>*
--- < user 0 | buffer : B, out-queue : nil, in-queue : nil, state : N, A >
--- < user 1 | buffer : B', out-queue : nil, in-queue : nil, state : N', A' >
--- C
--- such that B =/= B' and N =/= N' .
