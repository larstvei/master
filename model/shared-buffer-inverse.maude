load model-checker

--- Redefine CONFIGURATION for format
mod CONFIGURATION is
    sorts Attribute AttributeSet .
    subsort Attribute < AttributeSet .
    op none : -> AttributeSet  [ctor] .
    op _,_ : AttributeSet AttributeSet -> AttributeSet
        [ctor assoc comm id: none format (d d ntsss d)] .

    --- Removed Msg
    sorts Oid Cid Object Portal Configuration .
    subsort Object Portal < Configuration .
    op <_:_|_> : Oid Cid AttributeSet -> Object [ctor object] .
    op none : -> Configuration [ctor] .
    op __ : Configuration Configuration -> Configuration
        [ctor config assoc comm id: none format (d nn d)] .
    op <> : -> Portal [ctor] .
endm

--- Likewise for MAP
fmod MAP{X :: TRIV, Y :: TRIV} is
  protecting BOOL .
  sorts Entry{X,Y} Map{X,Y} .
  subsort Entry{X,Y} < Map{X,Y} .

  op _|->_ : X$Elt Y$Elt -> Entry{X,Y} [ctor] .
  op empty : -> Map{X,Y} [ctor] .
  op _,_ : Map{X,Y} Map{X,Y} -> Map{X,Y} [ctor assoc comm id: empty prec 121 format (d r onttssss d)] .
  op undefined : -> [Y$Elt] [ctor] .

  var D : X$Elt .
  vars R R' : Y$Elt .
  var M : Map{X,Y} .

  op insert : X$Elt Y$Elt Map{X,Y} -> Map{X,Y} .
  eq insert(D, R, (M, D |-> R')) =
     if $hasMapping(M, D) then insert(D, R, M)
     else (M, D |-> R)
     fi .
  eq insert(D, R, M) = (M, D |-> R) [owise] .

  op _[_] : Map{X,Y} X$Elt -> [Y$Elt] [prec 23] .
  eq (M, D |-> R)[D] =
     if $hasMapping(M, D) then undefined
     else R
     fi .
  eq M[D] = undefined [owise] .

  op $hasMapping : Map{X,Y} X$Elt -> Bool .
  eq $hasMapping((M, D |-> R), D) = true .
  eq $hasMapping(M, D) = false [owise] .
endfm

fmod STR is
    sort Str .
    ops a b c d e f g h i : -> Str .
endfm

view Str from TRIV to STR is
    sort Elt to Str .
endv

fmod BUFFER is
    pr LIST{Str} .
    pr STR .

    sort Buffer .
    subsort List{Str} < Buffer .
endfm

fmod ERROR is
    pr BUFFER .

    sort Error .
    subsort Buffer < Error .

    op error : -> Error [format (r o)] .

    var S : Str .

    eq S error = error .
    eq error S = error .
endfm

mod UNIQUE is
    pr CONFIGURATION .
    pr LIST{Str} .

    sort Unique .

    subsort Unique < Configuration .

    op [ _ ] : List{Str} -> Unique .
endm

mod ACTIONS is
    pr CONFIGURATION .
    pr NAT .

    sort Actions .
    subsort Actions < Configuration .

    op actions_ : Nat -> Actions .
endm

fmod USER is
    pr NAT .

    sort User .
    op user_ : Nat -> User .
endfm

view User from TRIV to USER is
    sort Elt to User .
endv

fmod ABSTRACT-OPERATION is

    sort Op .

    op nop : -> Op [ctor] .

    vars O O' : Op .

    op inv : Op -> Op .
    eq inv(nop) = nop .
    eq inv(inv(O)) = O .
    eq inv(O o O') = inv(O') o inv(O) .

    op _o_ : Op Op -> Op [assoc] .
    eq O o nop = O .
    eq nop o O = O .
    eq O o inv(O) = nop .
endfm

view Op from TRIV to ABSTRACT-OPERATION is
    sort Elt to Op .
endv

fmod INSERT-DELETE is
    pr ABSTRACT-OPERATION .
    pr NAT .
    pr STR .

    sort Type .

    ops ins del : -> Type .
    op ins : Nat Str -> Op [ctor format (g o)] .
    op del : Nat Str -> Op [ctor format (r o)] .

    var N : Nat .
    var S : Str .

    op pos : Op -> Nat .
    eq pos(ins(N, S)) = N .
    eq pos(del(N, S)) = N .

    op type : Op -> Type .
    eq type(ins(N,S)) = ins .
    eq type(del(N,S)) = del .
endfm

fmod TRANSFORMATION is
    pr INSERT-DELETE .

    vars N N' : Nat .
    vars S S' : Str .
    vars O O' O'' : Op .

    op  it : Op Op -> Op .
    ceq it(ins(N, S), del(N', S')) = ins(N, S) if N <= N' .
    eq  it(ins(N, S), del(N', S')) = ins(sd(N, 1), S) [owise] .

    ceq it(del(N, S), del(N', S')) = del(N, S) if N < N' .
    ceq it(del(N, S), del(N', S')) = del(sd(N, 1), S) if N > N' .
    eq  it(del(N, S), del(N', S')) = nop [owise] .

    eq  it(O, O' o O'') = it(it(O, O''), O') .
    eq  it(O, O') = O [owise] .

    op  et : Op Op -> Op .
    ceq et(ins(N, S), del(N', S')) = ins(N, S) if N <= N' .
    eq  et(ins(N, S), del(N', S')) = ins(s N, S) [owise] .

    ceq et(del(N, S), del(N', S')) = del(N, S) if N < N' .
    ceq et(del(N, S), del(N', S')) = del(s N, S) if N >= N' .
    eq  et(del(N, S), del(N', S')) = nop [owise] .

    eq  et(O, O' o O'') = et(et(O, O''), O') .
    eq  et(O, O') = O [owise] .
endfm

fmod APPLY is
    pr BUFFER .
    pr ERROR .
    pr INSERT-DELETE .

    vars Oi Oj : Op .
    vars S T : Str .
    var B : Buffer .
    var I : Nat .

    op apply_on_ : Op Buffer -> Buffer .
    eq apply nop on B = B .

    eq apply inv(ins(I,S)) on B = apply del(I,S) on B .
    eq apply inv(del(I,S)) on B = apply ins(I,S) on B .

    eq apply ins(0, S) on B = S B .
    eq apply ins(s I, S) on T B = T (apply ins(I, S) on B) .
    eq apply ins(s I, S) on nil = S .

    eq apply del(0, S) on T B = B .
    eq apply del(s I, S) on T B = T (apply del(I, S) on B) .
    eq apply del(I, S) on nil = error .

    eq apply Oi o Oj on B = apply Oi on (apply Oj on B) .

    eq apply Oi on error = error .
endfm

fmod MSG is
    pr NAT .
    pr ABSTRACT-OPERATION .

    sort Msg .

    op msg : Op Nat Nat -> Msg .
endfm

view Msg from TRIV to MSG is
    sort Elt to Msg .
endv

mod SITE is
    pr CONFIGURATION .
    pr BUFFER .
    pr LIST{Msg} .
    pr MSG .
    pr ABSTRACT-OPERATION .
    pr USER .

    sort Site .
    subsort Site < Configuration  .

    op <_|_> : User AttributeSet -> Object [ctor object] .
    op buffer :_ : Buffer -> Attribute .
    op seqno :_ : Nat -> Attribute .
    op state :_ : Nat -> Attribute .
    op in-queue :_ : List{Msg} -> Attribute .
    op out-queue :_ : List{Msg} -> Attribute .
endm

mod SITE-RULES is
    pr ACTIONS .
    pr APPLY .
    pr BUFFER .
    pr LIST{Msg} .
    pr MSG .
    pr ABSTRACT-OPERATION .
    pr USER .
    pr UNIQUE .
    pr SITE .

    vars B B' B'' : Buffer .
    vars I I' N M : Nat .
    var Q : List{Msg} .
    var O : Op .
    var S : Str .
    var U : User .
    var A : AttributeSet .

    rl [user-inserts] :
        actions s M
        [ S B'' ]
        < U | buffer : (B B'), seqno : N, state : I, out-queue : Q, A >
      =>
        actions M
        [ B'' ]
        < U | buffer : (B S B'), seqno : s N, state : I,
        out-queue : (msg(ins(size(B), S), I, N) Q), A > .

    rl [user-deletes] :
        actions s M
        < U | buffer : (B S B'), seqno : N, state : I, out-queue : Q, A >
      =>
        actions M
        < U | buffer : (B B'), seqno : s N, state : I,
        out-queue : (msg(del(size(B), S), I, N) Q), A > .

    crl [user-receive] :
        < U | buffer : B, seqno : N, state : I, in-queue : (Q msg(O,I',N)), A >
      =>
        < U | buffer : B', seqno : s N, state : I', in-queue : Q, A >
      if B' := apply O on B .

    crl [user-receive-reject] :
        < U | buffer : B, seqno : N, in-queue : (Q msg(O,I',M)), A >
      =>
        < U | buffer : B, seqno : s N, in-queue : Q, A >
      if N =/= M .
endm

mod SITE-INFO is
    pr NAT .

    sort Siteinfo .
     --- [state, seqno]
    op [_,_] : Nat Nat -> Siteinfo .
endm

view Siteinfo from TRIV to SITE-INFO is
    sort Elt to Siteinfo .
endv

fmod ORDERING is
    pr ABSTRACT-OPERATION .
    pr BOOL .
    pr INSERT-DELETE .
    pr NAT .
    pr SET{User} .

    sort Event .

    op ____ : Op Nat Nat Set{User} -> Event .

    vars I I' M M' : Nat .
    vars E E' : Event .
    vars O O' : Op .
    vars U U' : Set{User} .

    op concurrent : Event Event -> Bool .
    eq concurrent(O I M U, O' I' M' U') =
        intersection(U, U') == empty and
        ((I <= I' and I' <= M) or (I' <= I and I <= M')) .

    op _<_ : Event Event -> Bool .
    ceq O I M U < O' I' M' U' = pos(O) > pos(O')
        or (pos(O) == pos(O') and type(O) == del)
        or (pos(O) == pos(O') and type(O) == type(O') and M < M')
      if concurrent(O I M U, O' I' M' U') .
    eq O I M U < O' I' M' U' = M < M' [owise] .

    op _>_ : Event Event -> Bool .
    eq E > E' = E' < E .

endfm

view Event from TRIV to ORDERING is
    sort Elt to Event .
endv

fmod TOTALORDER is
    pr ORDERING .
    pr LIST{Event} .
    pr TRANSFORMATION .

    sort Totalorder .
    subsort List{Event} < Totalorder .

    vars M N I M' N' I' : Nat .
    vars O O' : Op .
    vars T T' T'' : Totalorder .
    vars U U' : Set{User} .
    vars E E' : Event .

    --- First enforce that an operation generated by a site follows every other
    --- operation generated by the same user.
    op  put : Event Totalorder -> Totalorder .
    eq  put(E, nil) = E .
    eq  put((O I M U), T (O' I' M' (U, U')) T') =
        put'((O I M U), T) (O' I' M' (U, U')) T' .
    eq  put(E, T) = put'(E, T) [owise] .

    op  put' : Event Totalorder -> Totalorder .
    eq  put'(E, nil) = E .
    ceq put'(E, E' T) = E E' T if E > E' .
    eq  put'(E, E' T) = E' put(E, T) [owise] .

    op compose : Totalorder -> Op .
    eq compose(nil) = nop .
    eq compose(T (O I M U)) = compose(T) o O .

    op  until : Totalorder Nat -> Totalorder .
    eq  until(nil, I') = nil .
    ceq until(T (O I M U), I') = T (O I M U) if M >= I' .
    eq  until(T (O I M U), I') = until(T, I') [owise] .

    op  fix : Totalorder -> Totalorder .
    eq  fix(nil) = nil .
    ceq fix((O I M U) T) = (O' I M U) T
      if O' := it(O, compose(filter((O I M U), T))) .

    op  unfix : Totalorder -> Totalorder .
    eq  unfix(nil) = nil .
    ceq unfix((O I M U) T) = (O' I M U) T
      if O' := et(O, compose(filter((O I M U), T))) .

    op  filter : Event Totalorder -> Totalorder .
    eq  filter(E, nil) = nil .
    ceq filter(E, E' T) = E' filter(E, T) if concurrent(E, E') .
    eq  filter(E, (O I M U') T) = filter(E, T) [owise] .

    op filter : User Totalorder -> Totalorder .
    eq filter(U, nil) = nil .
    eq filter(U, (O I M (U, U')) T) = (O I M U) filter(U, T) .
    eq filter(U, (O I M U') T) = filter(U, T) [owise] .

    op reset : Event Totalorder -> Op .
    eq reset(O I M U, T) = et(O, compose(filter(U, until(T, min(I, sd(I, 1)))))) .

    op same : Event Event Totalorder -> Bool .
    eq same(E, E', T) = concurrent(E, E') and reset(E, T) == reset(E', T) .

    ceq T (O I M U) T' (O' I' M' U') T'' =  T T' (O' I M union(U, U')) T''
      if same(O I M U, O' I' M' U', T' T'') .
endfm

mod SERVER is
    pr CONFIGURATION .
    pr MAP{User,Siteinfo} .
    pr SITE-INFO .
    pr NAT .
    pr TOTALORDER .

    op < server |_> : AttributeSet -> Object [ctor object] .
    op history :_ : Totalorder -> Attribute .
    op sites :_ : Map{User,Siteinfo} -> Attribute .
endm

mod SEND is
    pr CONFIGURATION .
    pr LIST{Msg} .
    pr MAP{User,Siteinfo} .
    pr SERVER .
    pr SITE .
    pr TOTALORDER .

    sort Send .
    subsort Send < Configuration .

    op send_to_ : Op Map{User, Siteinfo} -> Send .

    vars A A' : AttributeSet .
    vars O O' : Op .
    vars I I' N : Nat .
    vars US US' : Map{User,Siteinfo} .
    var U : User .
    var Q : List{Msg} .

    eq [send] : send O to empty = none .
    eq [send] :
        < U | in-queue : Q, A >
        < server | state : I, sites : (U |-> [I', N], US'), A' >
        send O to (U |-> [I', N], US)
      =
        < U | in-queue : (msg(O, I, N) Q), A >
        < server | state : I, sites : (U |-> [I', s N], US'), A' >
        send O to US .
endm

mod SERVER-RULES is
    pr CONFIGURATION .
    pr LIST{Msg} .
    pr MAP{User,Siteinfo} .
    pr ABSTRACT-OPERATION .
    pr SEND .
    pr SERVER .
    pr SITE .
    pr TOTALORDER .

    vars A A' : AttributeSet .
    vars Q Q' : List{Msg} .
    vars O O' : Op .
    vars O-1 O-1' : Op .
    vars I I' M N N' S S' : Nat .
    var U  : User .
    var E : Event .
    vars T T' : Totalorder .
    vars US US' : Map{User,Siteinfo} .

    crl [server-receive] :
        < U | out-queue : (Q msg(O,I,N)), A >
        < server | history : T, state : M, sites : (U |-> [I', N'], US), A' >
      =>
        < U | out-queue : Q, A >
        < server | history : T', state : s M, sites : US', A' >
        (send O' o O-1  to US)
        (send O' o O-1' to (U |-> [I, S']))
      if S'   := s N + sd(N, N') /\
         E    := O I M U /\
         US'  := (U |-> [I, S'], US) /\
         T'   := fix(put(E, T)) /\
         O'   := compose(until(T', I)) /\
         O-1  := inv(compose(until(T, I))) /\
         O-1' := inv(O o compose(filter(U, unfix(until(T, I))))) .
endm

mod PREDICATES is
    pr CONFIGURATION .
    pr LTL-SIMPLIFIER .
    pr MODEL-CHECKER .
    pr SATISFACTION .
    pr SITE .

    subsort Configuration < State .

    ops consistent inconsistent : -> Prop .

    vars A A' : AttributeSet .
    vars B B' : Buffer .
    vars U U' : User .
    var C : Configuration .
    
    ceq < U  | buffer : B,  A  >
        < U' | buffer : B', A' >
        C |= inconsistent = true if B =/= B' .

    eq C |= inconsistent = false [owise] .

    eq C |= consistent = not C |= inconsistent .
endm

mod TEST is
    pr ACTIONS .
    pr APPLY .
    pr BUFFER .
    pr CONFIGURATION .
    pr ERROR .
    pr MSG .
    pr ABSTRACT-OPERATION .
    pr PREDICATES .
    pr SERVER .
    pr SERVER-RULES .
    pr SITE .
    pr SITE-RULES .
    pr STR .
    pr TOTALORDER .
    pr TRANSFORMATION .
    pr UNIQUE .
    pr USER .

    var C : Configuration .
    var I : Nat .
    var I' : Nat .
    var N : Nat .
    var N' : Nat .
    var O : Op .
    vars Q Q' : List{Msg} .
    var U : User .
    var US : Map{User,Siteinfo} .
    vars A A' : AttributeSet .
    vars B B' B'' : Buffer .
    vars Oi Oj : Op .
    vars S T : Str .

    op init  : -> Configuration .
    eq init = init nil 2 .

    op init_ : Buffer -> Configuration .
    eq init B = init B 2 .

    op init__ : Buffer Nat -> Configuration .
    eq init B N =
        [ a b c d ]
        actions 3
        < server | history : nil, state : 0,
                   sites : sites N >
        clients B N .

    op clients__ : Buffer Nat -> Configuration .
    eq clients B 0 = none .
    eq clients B s N =
        < user N | buffer : B, seqno : 0, state : 0, out-queue : nil, in-queue : nil >
        clients B N .

    op sites_ : Nat -> Map{User,Siteinfo} .
    eq sites 0 = empty .
    eq sites s N = user N |-> [0, 0], sites N .
endm

--- search init =>*
--- < user 0 | buffer : B, out-queue : nil, in-queue : nil, state : N, A >
--- < user 1 | buffer : B', out-queue : nil, in-queue : nil, state : N', A' >
--- C
--- such that B =/= B' .

--- red modelCheck(init, [] <> consistent) .
