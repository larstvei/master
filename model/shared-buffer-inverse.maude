load model-checker

--- Redefine CONFIGURATION for format
mod CONFIGURATION is
    sorts Attribute AttributeSet .
    subsort Attribute < AttributeSet .
    op none : -> AttributeSet  [ctor] .
    op _,_ : AttributeSet AttributeSet -> AttributeSet
        [ctor assoc comm id: none format (d d ntsss d)] .

    --- Removed Msg
    sorts Oid Cid Object Portal Configuration .
    subsort Object Portal < Configuration .
    op <_:_|_> : Oid Cid AttributeSet -> Object [ctor object] .
    op none : -> Configuration [ctor] .
    op __ : Configuration Configuration -> Configuration
        [ctor config assoc comm id: none format (d nn d)] .
    op <> : -> Portal [ctor] .
endm

--- Likewise for MAP
fmod MAP{X :: TRIV, Y :: TRIV} is
  protecting BOOL .
  sorts Entry{X,Y} Map{X,Y} .
  subsort Entry{X,Y} < Map{X,Y} .

  op _|->_ : X$Elt Y$Elt -> Entry{X,Y} [ctor] .
  op empty : -> Map{X,Y} [ctor] .
  op _,_ : Map{X,Y} Map{X,Y} -> Map{X,Y} [ctor assoc comm id: empty prec 121 format (d r onttssss d)] .
  op undefined : -> [Y$Elt] [ctor] .

  var D : X$Elt .
  vars R R' : Y$Elt .
  var M : Map{X,Y} .

  op insert : X$Elt Y$Elt Map{X,Y} -> Map{X,Y} .
  eq insert(D, R, (M, D |-> R')) =
     if $hasMapping(M, D) then insert(D, R, M)
     else (M, D |-> R)
     fi .
  eq insert(D, R, M) = (M, D |-> R) [owise] .

  op _[_] : Map{X,Y} X$Elt -> [Y$Elt] [prec 23] .
  eq (M, D |-> R)[D] =
     if $hasMapping(M, D) then undefined
     else R
     fi .
  eq M[D] = undefined [owise] .

  op $hasMapping : Map{X,Y} X$Elt -> Bool .
  eq $hasMapping((M, D |-> R), D) = true .
  eq $hasMapping(M, D) = false [owise] .
endfm

fmod STR is
    sort Str .
    ops a b c d e f g h i : -> Str .
endfm

view Str from TRIV to STR is
    sort Elt to Str .
endv

fmod BUFFER is
    pr LIST{Str} .
    pr STR .

    sort Buffer .
    subsort List{Str} < Buffer .
endfm

fmod ERROR is
    pr BUFFER .

    sort Error .
    subsort Buffer < Error .

    op error : -> Error [format (r o)] .
endfm

mod UNIQUE is
    pr CONFIGURATION .
    pr LIST{Str} .

    sorts Unique .

    subsort Unique < Configuration .

    op [ _ ] : List{Str} -> Unique .
endm

mod ACTIONS is
    pr CONFIGURATION .
    pr NAT .

    sort Actions .
    subsort Actions < Configuration .

    op actions_ : Nat -> Actions .
endm

fmod USER is
    pr NAT .

    sort User .
    op user_ : Nat -> User .
endfm

view User from TRIV to USER is
    sort Elt to User .
endv

fmod ABSTRACT-OPERATION is

    sort Op .

    op nop : -> Op [ctor] .

    vars O O' : Op .

    op inv : Op -> Op .
    eq inv(nop) = nop .
    eq inv(inv(O)) = O .
    eq inv(O o O') = inv(O') o inv(O) .

    op _o_ : Op Op -> Op [assoc] .
    eq O o nop = O .
    eq nop o O = O .
    eq O o inv(O) = nop .
endfm

view Op from TRIV to ABSTRACT-OPERATION is
    sort Elt to Op .
endv

fmod INSERT-DELETE is
    pr ABSTRACT-OPERATION .
    pr NAT .
    pr STR .

    sort Type .

    ops ins del : -> Type .
    op ins : Nat Str -> Op [ctor format (g o)] .
    op del : Nat Str -> Op [ctor format (r o)] .

    var N : Nat .
    var S : Str .

    op point : Op -> Nat .
    eq point(ins(N, S)) = N .
    eq point(del(N, S)) = N .

    op type : Op -> Type .
    eq type(ins(N,S)) = ins .
    eq type(del(N,S)) = del .
endfm

fmod TRANSFORMATIONS is
    pr LIST{Op} .
    pr ABSTRACT-OPERATION .

    vars O O' : Op .
    var OPS : List{Op} .

    op compose : List{Op} -> Op .
    eq compose(nil) = nop .
    eq compose(O) = O .
    eq compose(O O') = O o O' .
    eq compose(O O' OPS) = O o O' o compose(OPS) .
endfm

fmod APPLY is
    pr BUFFER .
    pr ERROR .
    pr INSERT-DELETE .

    vars Oi Oj : Op .
    vars S T : Str .
    var B : Buffer .
    var I : Nat .

    op apply_on_ : Op Buffer -> Buffer .
    eq apply nop on B = B .

    eq apply inv(ins(I,S)) on B = apply del(I,S) on B .
    eq apply inv(del(I,S)) on B = apply ins(I,S) on B .

    eq apply ins(0, S) on B = S B .
    eq apply ins(s I, S) on T B = T (apply ins(I, S) on B) .
    eq apply ins(s I, S) on nil = error .

    eq apply del(0, S) on S B = B .
    ceq apply del(0, S) on T B = error if S =/= T .
    eq apply del(s I, S) on T B = T (apply del(I, S) on B) .
    eq apply del(I, S) on nil = error .

    eq apply Oi o Oj on B = apply Oi on (apply Oj on B) .

    eq apply Oi on error = error .
endfm

fmod MSG is
    pr NAT .
    pr ABSTRACT-OPERATION .

    sort Msg .

    op msg : Op Nat Nat -> Msg .
endfm

view Msg from TRIV to MSG is
    sort Elt to Msg .
endv

mod SITE is
    pr CONFIGURATION .
    pr BUFFER .
    pr LIST{Msg} .
    pr MSG .
    pr ABSTRACT-OPERATION .
    pr USER .

    sort Site .
    subsort Site < Configuration  .

    op <_|_> : User AttributeSet -> Object [ctor object] .
    op buffer :_ : Buffer -> Attribute .
    op seqno :_ : Nat -> Attribute .
    op state :_ : Nat -> Attribute .
    op in-queue :_ : List{Msg} -> Attribute .
    op out-queue :_ : List{Msg} -> Attribute .
endm

mod SITE-RULES is
    pr ACTIONS .
    pr APPLY .
    pr BUFFER .
    pr LIST{Msg} .
    pr MSG .
    pr ABSTRACT-OPERATION .
    pr USER .
    pr UNIQUE .
    pr SITE .

    vars B B' B'' : Buffer .
    vars I I' N M : Nat .
    var Q : List{Msg} .
    var O : Op .
    var S : Str .
    var U : User .
    var A : AttributeSet .

    rl [user-inserts] :
        actions s M
        [ S B'' ]
        < U | buffer : (B B'), seqno : N, state : I, out-queue : Q, A >
      =>
        actions M
        [ B'' ]
        < U | buffer : (B S B'), seqno : s N, state : I,
        out-queue : (msg(ins(size(B), S), I, N) Q), A > .

    rl [user-deletes] :
        actions s M
        < U | buffer : (B S B'), seqno : N, state : I, out-queue : Q, A >
      =>
        actions M
        < U | buffer : (B B'), seqno : s N, state : I,
        out-queue : (msg(del(size(B), S), I, N) Q), A > .

    crl [user-receive] :
        < U | buffer : B, seqno : N, state : I, in-queue : (Q msg(O,I',N)), A >
      =>
        < U | buffer : B', seqno : s N, state : I', in-queue : Q, A >
      if B' := apply O on B .

    crl [user-receive-reject] :
        < U | buffer : B, seqno : N, in-queue : (Q msg(O,I',M)), A >
      =>
        < U | buffer : B, seqno : s N, in-queue : Q, A >
      if N =/= M .
endm

mod SITE-INFO is
    pr LIST{Op} .
    pr NAT .

    sort Siteinfo .
    --- [seqno, operations]
    op [_,_] : Nat List{Op} -> Siteinfo .
endm

view Siteinfo from TRIV to SITE-INFO is
    sort Elt to Siteinfo .
endv

fmod TOTALORDER is
    pr ABSTRACT-OPERATION .
    pr INSERT-DELETE .
    pr NAT .
    pr STR .
    pr USER .

    sorts Item Totalorder .
    subsort Item < Totalorder .

    op empty : -> Totalorder .
    op __ : Totalorder Totalorder -> Totalorder [assoc id: empty] .
    op ___ : Op Nat User -> Item .

    vars N I N' I' : Nat .
    var IT : Item .
    vars O O' : Op .
    vars S S' : Str .
    vars U U' : User .
    var T : Totalorder .

    op put : Item Totalorder -> Totalorder .
    eq put(IT, empty) = IT .

    ceq put(O I U, (O' I' U') T) = (O' I' U') put(O I U, T)
      if I < I' /\ U =/= U' .

    ceq put(O I U, (O' I' U') T) = (O I U) (O' I' U') T
      if U == U' .

    ceq put(O I U, (O I U') T) = (O I U) T
      if U =/= U' .

    ceq put(O I U, (O' I' U') T) = (O' I' U') (O I U) T
      if point(O) > point(O') /\ I == I' /\ U =/= U' .

    ceq put(O I U, (O' I' U') T) = (O' I' U') (O I U) T
      if type(O) == del /\ point(O) == point(O') /\ I == I' /\ U =/= U' .

    eq put(O I U, (O' I' U') T) = (O I U) (O' I' U') T [owise] .

    op size : Totalorder -> Nat .
    eq size(empty) = 0 .
    eq size(IT T) = s size(T) .

    op takeop : Totalorder Nat -> Op .
    eq takeop(T, 0) = nop .
    eq takeop((O I U) T, s N) = O o takeop(T, N) .

    op getop : Totalorder Nat -> Op .
    ceq getop((O I U) T, I') = O o getop(T, I') if I >= I' .
    eq getop(T, I') = nop [owise] .
    ---eq getop(T, I) = takeop(T, sd(size(T), I)) .
endfm

mod SERVER is
    pr CONFIGURATION .
    pr MAP{User,Siteinfo} .
    pr SITE-INFO .
    pr NAT .
    pr TOTALORDER .

    op < server |_> : AttributeSet -> Object [ctor object] .
    op history :_ : Totalorder -> Attribute .
    op sites :_ : Map{User,Siteinfo} -> Attribute .
endm

mod SEND is
    pr CONFIGURATION .
    pr LIST{Msg} .
    pr MAP{User,Siteinfo} .
    pr SERVER .
    pr SITE .
    pr TOTALORDER .
    pr TRANSFORMATIONS .

    sort Send .
    subsort Send < Configuration .

    op send_to_ : Op Map{User, Siteinfo} -> Send .

    vars A A' : AttributeSet .
    vars O O' : Op .
    vars I N : Nat .
    vars US US' : Map{User,Siteinfo} .
    var U : User .
    var Q : List{Msg} .
    var OPS : List{Op} .

    eq  [send] : send O to empty = none .
    eq [send] :
        < U | in-queue : Q, A >
        < server | state : I, sites : (U |-> [N, OPS], US'), A' >
        send O to (U |-> [N, OPS], US)
      =
        < U | in-queue : (msg(O, I, N) Q), A >
        < server | state : I, sites : (U |-> [s N, OPS], US'), A' >
        send O to US .
endm

mod SERVER-RULES is
    pr CONFIGURATION .
    pr LIST{Msg} .
    pr MAP{User,Siteinfo} .
    pr ABSTRACT-OPERATION .
    pr SEND .
    pr SERVER .
    pr SITE .
    pr TOTALORDER .
    pr TRANSFORMATIONS .

    vars A A' : AttributeSet .
    vars Q Q' : List{Msg} .
    vars O O' O'' : Op .
    vars I I' N N' S S' : Nat .
    vars OPS OPS' : List{Op} .
    var U  : User .
    vars T T'  : Totalorder .
    vars US US' : Map{User,Siteinfo} .

    crl [server-receive] :
        < U | out-queue : (Q msg(O,I,N)), A >
        < server | history : T, state : I', sites : (U |-> [N', OPS], US), A' >
      =>
        < U | out-queue : Q, A >
        < server | history : T', state : s I', sites : US', A' >
        (send O' o O'' to US)
        (send O' o inv(compose(O OPS')) to (U |-> [S', O OPS']))
      if S'   := s N + sd(I, I') /\
         OPS' := if I == I' then nil else OPS fi /\
         US'  := (U |-> [S', O OPS'], US) /\
         T'   := put(O I U, T) /\
         O'   := getop(T', I) /\
         O''  := inv(getop(T, I)) .
endm

mod PREDICATES is
    pr CONFIGURATION .
    pr LTL-SIMPLIFIER .
    pr MODEL-CHECKER .
    pr SATISFACTION .
    pr SITE .

    subsort Configuration < State .

    ops consistent inconsistent : -> Prop .

    vars A A' : AttributeSet .
    vars B B' : Buffer .
    vars U U' : User .
    var C : Configuration .
    
    ceq < U  | buffer : B,  A  >
        < U' | buffer : B', A' >
        C |= inconsistent = true if B =/= B' .

    eq C |= inconsistent = false [owise] .

    eq C |= consistent = not C |= inconsistent .
endm

mod TEST is
    pr ACTIONS .
    pr APPLY .
    pr BUFFER .
    pr CONFIGURATION .
    pr ERROR .
    pr MSG .
    pr ABSTRACT-OPERATION .
    pr PREDICATES .
    pr SERVER .
    pr SERVER-RULES .
    pr SITE .
    pr SITE-RULES .
    pr STR .
    pr TRANSFORMATIONS .
    pr UNIQUE .
    pr USER .

    op init  : -> Configuration .
    op init_ : Buffer -> Configuration .

    var C : Configuration .
    var I : Nat .
    var I' : Nat .
    var N : Nat .
    var N' : Nat .
    var O : Op .
    var OPS : List{Op} .
    vars Q Q' : List{Msg} .
    var U : User .
    var US : Map{User,Siteinfo} .
    vars A A' : AttributeSet .
    vars B B' B'' : Buffer .
    vars Oi Oj : Op .
    vars S T : Str .

    eq init = init nil .

    eq init B =
        [ a b c d ]
        actions 2
        < user 0 | buffer : B, seqno : 0, state : 0, out-queue : nil, in-queue : nil >
        < user 1 | buffer : B, seqno : 0, state : 0, out-queue : nil, in-queue : nil >
        < server | history : empty, state : 0,
                   sites : (user 0 |-> [0, nil], user 1 |-> [0, nil]) > .
endm

--- search init =>*
--- < user 0 | buffer : B, out-queue : nil, in-queue : nil, state : N, A >
--- < user 1 | buffer : B', out-queue : nil, in-queue : nil, state : N', A' >
--- C
--- such that B =/= B' and N =/= N' .
