load model-checker .

view Oid from TRIV to CONFIGURATION is
    sort Elt to Oid .
endv

mod GLOBAL is
    including NAT .
    including LIST{Nat} .
    including CONFIGURATION .
    including STRING .
    sorts NextStr Str .
    subsort NextStr < Configuration .
    subsort Nat < Str .
    subsort String < Oid .

    op next_ : Str       -> NextStr [format (n s n)] .
    op max   : List{Nat} -> Nat .

    var N : Nat .
    var L : List{Nat} .

    eq max(N)   = N .
    eq max(N L) = if N > max(L) then N else max(L) fi .
endm

mod MSG is
    including GLOBAL .

    sort MsgContent .

    op ack : -> Msg [ctor] .
    op ins : Str Nat Nat -> MsgContent [ctor] .
    op del : Nat Nat Nat -> MsgContent [ctor] .

    msg _from_to_ : MsgContent Oid Oid -> Msg
    [format (r d d d d o)] .
endm

mod QUEUE is
    including MSG .
    sort MsgQueue .
    subsort Msg < MsgQueue .

    op empty : -> MsgQueue [ctor] .
    op _~_   : MsgQueue MsgQueue -> MsgQueue [ctor assoc id: empty] .
endm

mod SERVER is
    including QUEUE .
    including SET{Oid} .

    sort Server .

    op <_: Server | clients :_> : Oid Set{Oid} -> Object
        [format (n s s s s s s s s n)] .
endm

mod CLIENT is
    including SERVER .

    sorts Client Content .
    subsort List{Nat} < Content .

    op ins_at_in_ : Str Nat    Content -> Content .
    op del_at_in_ : Nat Nat    Content -> Content .
    op receive__  : MsgContent Content -> Content .

    op <_: Client | content :_, seqNo :_, out-channel :_, in-channel :_, operations-left :_> :
        Oid Content Nat MsgQueue MsgQueue Nat -> Object
        [format (n s s s s n++i s s s ni s s s ni s s s ni s s s ni-- s s s n)] .

    var C      : Content .
    var S      : Str .
    vars I M N : Nat .

    eq ins S at 0 in C   = S C .
    eq ins S at s I in C = head(C) (ins S at I in tail(C)) .

    *** Assuming N is 1, change this later?
    eq del 1 at 0 in C   = tail(C) .
    eq del 1 at s I in C = head(C) (del 1 at I in tail(C)) .

    eq receive ins(S,I,N) C = ins S at I in C .
    eq receive del(M,I,N) C = del M at I in C .
endm

mod SERVER-RULES is
    including CLIENT .

    sort Multicast .
    subsort Multicast < Configuration .

    op multicast_from_to_ : MsgContent Oid Set{Oid} -> Multicast .

    vars Q Q' : MsgQueue .
    vars O O' : Oid .
    vars N N' : Nat .
    var  C    : Content .
    var  CS   : Set{Oid} .
    var  M    : MsgContent .

    rl [server-receive] :
        < O  : Client | content : C,
                        seqNo : N,
                        out-channel : Q ~ (M from O to O'),
                        in-channel : Q',
                        operations-left : N' >
        < O' : Server | clients : O, CS >
      =>
        < O  : Client | content : C,
                        seqNo : N,
                        out-channel : Q,
                        in-channel : Q',
                        operations-left : N' >
        < O' : Server | clients : O, CS >
        multicast M from O' to CS .

    eq multicast M from O' to empty = none .

    eq < O : Client | content : C,
                      seqNo : N,
                      out-channel : Q',
                      in-channel : Q,
                      operations-left : N' >
        multicast M from O' to (O, CS)
      =
        < O : Client | content : C,
                       seqNo : N,
                       out-channel : Q',
                       in-channel : (M from O' to O) ~ Q,
                       operations-left : N' >
        multicast M from O' to CS .
endm

mod CLIENT-RULES is
    including SERVER-RULES .

    vars O O' : Oid .
    vars N N' : Nat .
    vars S S' : Str .
    vars C C' : Content .
    vars Q Q' : MsgQueue .
    var CS    : Set{Oid} .
    var NZ    : NzNat .
    var M     : MsgContent .

    rl [user-inserts] :
        < O  : Client | content : C C',
                        seqNo : N,
                        out-channel : Q,
                        in-channel : Q',
                        operations-left : NZ >
        < O' : Server | clients : CS >
        next S
      =>
        < O  : Client | content : C S C',
                        seqNo : s N,
                        out-channel : (ins(S, size(C), N) from O to O') ~ Q,
                        in-channel : Q',
                        operations-left : sd(NZ, 1) >
        < O' : Server | clients : CS >
        next s S .

    rl [user-deletes] :
        < O  : Client | content : C S C',
                        seqNo : N,
                        out-channel : Q,
                        in-channel : Q',
                        operations-left : NZ >
        < O' : Server | clients : CS >
      =>
        < O  : Client | content : C C',
                        seqNo : s N ,
                        out-channel : (del(1, size(C), N) from O to O') ~ Q,
                        in-channel : Q',
                        operations-left : sd(NZ, 1) >
        < O' : Server | clients : CS > .

    rl [user-receive] :
        < O : Client | content : C,
                       seqNo : N,
                       out-channel : Q',
                       in-channel : Q ~ (M from O' to O),
                       operations-left : N' >
      =>
        < O : Client | content : receive M C,
                       seqNo : N,
                       out-channel : Q',
                       in-channel : Q,
                       operations-left : N' > .
endm

mod TEST is
    including CLIENT-RULES .

    subsort String < Oid .

    op init__        : Content Set{Oid} -> Configuration .   --- a suitable initial state
    op initclients__ : Content Set{Oid} -> Configuration .   --- a suitable initial state

    var O  : Oid .
    var C  : Content .
    var CF : Configuration .
    var CS : Set{Oid} .

    eq init C CS =
        < "S" : Server | clients : CS >
        (initclients C CS)
        next if C == nil then 0 else s(max(C)) fi .

    eq initclients C empty   = none .
    eq initclients C (O, CS) =
        < O : Client | content : C,
                       seqNo : 0,
                       out-channel : empty,
                       in-channel : empty,
                       operations-left : 3 >
        (initclients C CS) .
endm

mod PREDICATES is
    including TEST .
    including SATISFACTION .
    including MODEL-CHECKER .
    including LTL-SIMPLIFIER .

    subsort Configuration < State .

    ops consistent inconsistent : -> Prop .

    vars C C'          : Content .
    vars O O'          : Oid .
    vars N N' N'' N''' : Nat .
    vars Q Q' Q'' Q''' : MsgQueue .
    var  CF            : Configuration .

    ceq < O  : Client | content : C,
                        seqNo : N,
                        out-channel : Q,
                        in-channel : Q',
                        operations-left : N' >
        < O' : Client | content : C',
                        seqNo : N'',
                        out-channel : Q'',
                        in-channel : Q''',
                        operations-left : N''' >
        CF |= inconsistent = true if C =/= C' .

    eq CF |= inconsistent = false [owise] .

    eq CF |= consistent = not CF |= inconsistent .

    eq CF |= inconsistent = false [owise] .
endm

*** Commands:

--- frew[10] init(nil) .

--- Finds example after 9 steps
--- search[1] init nil "C1" =>*
--- < "C1" : Client | content         : (head(nil)(ins S:Str at 0 in tail(nil))),
---                   seqNo           : N:Nat,
---                   out-channel     : Q:MsgQueue,
---                   in-channel      : Q':MsgQueue,
---                   operations-left : N':Nat > C:Configuration .

--- search[1]
---     next 0
---     < "S"  : Server | clients : "C1", "C2" >
---     < "C1" : Client | content : nil, seqNo : 0, out-channel : empty, in-channel : empty, operations-left : 3 >
---     < "C2" : Client | content : nil, seqNo : 0, out-channel : empty, in-channel : empty, operations-left : 3 >
---   =>*
---     < "C1" : Client | content : (head(nil)(ins S:Str at 0 in tail(nil))),
---                       seqNo   : N:Nat,
---                       out     : Q:MsgQueue,
---                       in      : Q':MsgQueue,
---                       operations-left     : N':Nat > C:Configuration .

--- red modelCheck(init nil ("C1", "C2"), (inconsistent -> <> consistent)) .
red modelCheck(init nil ("C1", "C2"), [] <> consistent ) .
